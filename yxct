#!/usr/bin/env bash

if [ -z "${CMD}" ]; then
  CMD=$(basename $0)
fi


if [ -z "${SOURCE}" ]; then
  SOURCE="$0"
  DIR=
  while [ -h "$SOURCE"  ]; do
    DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd  )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /*  ]] && SOURCE="$DIR/$SOURCE"
  done
  DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd  )"
fi


if [ -z "${YXCT_USEYXLIB}" ]; then
  if which yxlibinit > /dev/null; then
    source yxlibinit -
    source yxlogger
    export YXCT_USEYXLIB=true
  else
    export YXCT_USEYXLIB=false
  fi
elif "${YXCT_USEYXLIB}"; then
  source yxlogger
fi



BIN_PATH='/bin'
SBIN_PATH='/sbin'
USR_BIN_PATH='/usr/bin'
USR_SBIN_PATH='/usr/sbin'
USR_LOCAL_BIN_PATH='/usr/local/bin'
USR_LOCAL_SBIN_PATH='/usr/local/sbin'
DEFAULT_BIN_PATH="${USR_LOCAL_BIN_PATH}"


# index about
YXCT_INDEX_DEFAULT_GIT_ADDR='git@github.com:magiclyx/yxctindex.git'
YXCT_INDEX_DEFAULT_GIT_BRANCH='main'
YXCT_INDEX_DEFAULT_SCHEDULE=7day


#Display comand only, not run
if [ -z "${TEST_ONLY}" ]; then
  TEST_ONLY=false
fi

##############################################################
# !! 因为yxct不能用YXLib, 下面这些变量必须与yxlogger 中定义的相同
##############################################################
readonly YXCT_LEVEL_SILENT=0
readonly YXCT_LEVEL_FATAL=1
readonly YXCT_LEVEL_ERROR=4
readonly YXCT_LEVEL_WARN=5
readonly YXCT_LEVEL_INFO=8
readonly YXCT_LEVEL_VERBOSE=9
readonly YXCT_LEVEL_DEBUG=11
readonly YXCT_LEVEL_TRACE=12
readonly YXCT_LEVEL_ALL=99

if [ -z "${YXCT_DEFAULT_LEVEL}" ]; then
  YXCT_DEFAULT_LEVEL="${YXCT_LEVEL_INFO}"
fi


###########################################################
# Ignore file list in script folder
###########################################################

IGNORE_LIST=(
  # git
  "^\.gitignore$"
  "^\.git$"
  "^\.gitkeep$"
  
  ################
  #vim
  # # vim->swap
  "^[._]*\.s[a-v][a-z]$"
  "^[._]*.sw[a-p]$"
  "^[._]s[a-rt-v][a-z]$"
  "^[._]ss[a-gi-z]$"
  "^[._]sw[a-p]$"
  # # vim->session
  "^Session$"
  "^Sessionx$"
  # # vim->Temporary
  "^\.netrwhist$"
  "^\*~$"
  # # vim->Auto-generated tag files
  "^tags$"
  # # vim->Persistent undo
  "^[._]*.un~$"
  
  ################
  #vscode
  "^\.vscode$"
  # # vscode->Local History for Visual Studio Code
  "^\.history$"
  # # vscode->Built Visual Studio Code Extensions
  "^.*\.vsix$"
  # # vscode->VisualStudioCode Patch
  "^\.history$"
  "^\.ionide$"
  
  # custom
  "^README(\.md)?$"
  "^test(\.sh)?$"
  "^sample(\.sh)?$"
)


###########################################################
# YXLib
###########################################################
# 第一个参数，必须是script path.
function yxct_run_script()
{
  # get script file path from command
  local script_path=$(echo $@ | awk '{print $1}')
  
  if [ -n "${script_path}" ]; then
    
    # get shebang line from command
    local shebang=$(head -n 1 "${script_path}")
    if echo ${shebang} | grep -Eq "^#!.*"; then
      # if shebang exist, call commmand directly
      yxct_verbcmd "eval $@"
    else
      # try get file extension name
      local file_ext=${script_path##*.}

      # call command by extension name
      if [ -n "${file_ext}" ]; then
        if yxct_strcontains "${file_ext}" "sh" --ignorecase; then
          yxct_verbcmd "eval ${BASH} $@"
        elif yxct_strcontains "${file_ext}" "py" --ignorecase; then
          yxct_verbcmd "eval ${ENV} python3 $@"
        else
          yxct_verbcmd "eval $@"
        fi
      fi

    fi # end of (echo ${title} | grep -Eq "^#!.*"; then)
  fi # end of (if [ -n "${script_path}" ]; then)
}


function yxct_os_type()
{
  
  local release=''
  
  if [ -n "${OSTYPE}" ]; then
    if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
      release="linux"
    elif [[ "${OSTYPE}" == "bsd"* ]]; then 
      release="bsd"
    elif [[ "${OSTYPE}" == "freebsd"* ]]; then 
      release="freebsd"
    elif [[ "${OSTYPE}" == "darwin"* ]]; then 
      release="osx"
    elif [[ "${OSTYPE}" == "solaris"* ]]; then 
      release="solaris"
    elif [[ "${OSTYPE}" == "cygwin" ]]; then 
      # POSIX compatibility layer and Linux environment emulation for Windows 
      release="cygwin"
    elif [[ "${OSTYPE}" == "msys" ]]; then 
      # Lightweight shell and GNU utilities compiled for Windows (part of MinGW) 
      release="msys"
    elif [[ "${OSTYPE}" == "win32" ]]; then 
      # I'm not sure this can happen. 
      release="windows"
    else 
      release="unknown"
    fi
  else
    
    # $OSTAYPE not recognized by the older shells (such as Bourne shell).
    # Use `uname` instead
    
    case $(uname | tr '[:upper:]' '[:lower:]') in
      linux*)
        release='linux'
      ;;
      freebsd*)
        release='freebsd'
      ;;
      darwin*)
        release="osx"
      ;;
      SunOS*)
        release="solaris"
      ;;
      msys*)
        release="msys"
      ;;
      windows*)
        release="windows"
      ;;
      *)
        release="unknown"
      ;;
    esac
  fi
  

  echo "${release}"
}

function yxct_verbose()
{
  if ${YXCT_USEYXLIB}; then
    yx_verb $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_VERBOSE}" )); then
      return
    fi

    (>&1 echo "$1")

  fi


}

function yxct_msg()
{
  if ${YXCT_USEYXLIB}; then
    yx_msg $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_INFO}" )); then
      return
    fi

    echo $*

  fi


}

function yxct_fatal()
{
  YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

  if ${YXCT_USEYXLIB}; then
    yx_fatal $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" >= "${YXCT_LEVEL_FATAL}" )); then
      local red=$(tput setaf 1);
      local reset=$(tput sgr0);
      
      (>&2 echo "${red}Fatal:${1}${reset}");
    fi

    exit 1;

  fi


}


function yxct_verbcmd()
{
  if ${YXCT_USEYXLIB}; then
    if ${TEST_ONLY}; then
      yx_verbcmd --test $@
    else
      yx_verbcmd $@
    fi
  else
    if ${TEST_ONLY}; then
      yxct_verbose "Test-only:$*"
      return
    else
      yxct_verbose "$*"
    fi

    $@
  fi


}

function yxct_err()
{
  if ${YXCT_USEYXLIB}; then
    yx_err $@
  else
    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_ERROR}" )); then
      return
    fi

    local magenta=$(tput setaf 5);
    local reset=$(tput sgr0);

    (>&2 echo "${magenta}${1}${reset}")
  fi

}

function yxct_warn()
{
  if ${YXCT_USEYXLIB}; then
    yx_warn $@
  else
    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_WARN}" )); then
      return
    fi

    local yellow=$(tput setaf 3);
    local reset=$(tput sgr0);

    (>&2 echo "${yellow}${1}${reset}")
  fi
}

function yxct_str_checkfmt()
{
  local reg=$1
  local str=$2
  
  if [[ -z ${str} ]]; then
    str=''
  fi
  
  if [[ -z ${reg} ]]; then
    reg='^\s*[^\s]+\s*$'
  fi
  
  if ! [[ ${str} =~ ${reg} ]] ; then
    return 1
  fi
  
  return 0
}

function yxct_strcontains()
{
  local str="$1"
  local arr_str="$2"
  local ignorecase=false
  shift 
  shift 
  
  while [ $# -gt 0 ]; do
    case $1 in
      
      --ignorecase )
        ignorecase=true
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done

  
  if ${ignorecase}; then
    if [[ $(yxct_shell_type) == 'bash' ]]; then
      for e in $(echo "${arr_str}"); do
        [[ "${e^^}" == "${str^^}" ]] && return 0
      done
    else
      for e in $(echo "${arr_str}"); do
        [[ "${e:u}" == "${str:u}" ]] && return 0
      done
    fi
  else
    for e in $(echo "${arr_str}"); do
      [[ "${e}" == "${str}" ]] && return 0
    done
  fi
  
  return 1
}

function yxct_shell_type()
{
  local shell_type=
  if [ -n "${ZSH_VERSION}" ]; then
    shell_type='zsh'
  elif [ -n "${BASH_VERSION}" ]; then
    shell_type='bash'
  else
    :
  fi

  echo "${shell_type}"
}

# usage yxct_is_subpath <path> <sub_path>
function yxct_is_subpath()
{
	local path=$1
	local sub_path=$2
	
	if [ -z "${path}" ]; then
		yxct_fatal "path is empty"
	fi
	
	if [ -z "${sub_path}" ]; then
		yxct_fatal "sub-path is empty"
	fi
	
	
	if [[ "${sub_path##${path}}" != "${sub_path}" ]]; then
		return 0
	else
		return 1
	fi
}

function yxct_datastr_to_second()
{
	local -A REG_MAP
	REG_MAP=(
		[YEAR]='(y|year|years)'
		[MONTH]='(mon|month|months)'
		[DAY]='(d|day|days)'
		[HOUR]='(h|hour|hours)'
		[MINUTE]='(m|min|minute|minutes)'
		[SECOND]='(s|sec|second|seconds)'
	)
	
	local -A SECOND_MAP
	SECOND_MAP=(
		[YEAR]='31104000'
		[MONTH]='2592000'
		[DAY]='86400'
		[HOUR]='3600'
		[MINUTE]='60'
		[SECOND]='1'
	)
	
	
	local result=0
	local date_str=$(echo "${1}" | tr '[:upper:]' '[:lower:]' | grep -o "[^ ]\+\( \+[^ ]\+\)*")
	for tag in YEAR MONTH DAY HOUR MINUTE SECOND; do	
		local section=$(echo "${date_str}" | grep -oE "^[[:space:]]*[1-9][0-9]*${REG_MAP[${tag}]}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
		
		if [ -n "${section}" ]; then
			
			local num=$(echo "${section}" | grep -oE "^[[:space:]]*[1-9][0-9]*" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
			if [ -z "${num}" ]; then
				yxct_fatal "invalid time format:$1"
			fi
			

			((result=result+SECOND_MAP["${tag}"]*num))
			
			
			local fix_section=$(echo "${section}" | _yxct_sed_escape)
			date_str=$(echo "${date_str}" | sed -e "s/^${fix_section}//g")
		fi
		
	done
	
	if ! [ -z "${date_str}" ]; then
		yxct_fatal "invalid time format:$1"
  else
    echo "${result}"
	fi
	
}

###########################################################
# version compare
###########################################################

function yxct_math_short()
{
	local num=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' num
		#    num=`cat < /dev/stdin`
	else
		num=$1
	fi
	
	if [[ -z ${num} ]]; then
		echo 0
	else
		result=`echo ${num} | sed 's/^0*//'`
		
		if [[ -z ${result} ]]; then
			echo 0
		else
			echo ${result}
		fi
	fi
}

function yxct_strvercmp_zsh()
{
	
	if [[ $1 == $2 ]]
	then
		return 0
	fi
	
	local IFS=.
	local i ver1=($1) ver2=($2)
	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}+1; i<=${#ver2[@]}; i++)); do
		ver1[i]=0
	done
	
	
	for ((i=1; i<=${#ver1[@]}; i++))
	do
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		
		
		local ver1_num=${ver1[i]}    
		if [[ -z ${ver1_num} ]]; then
			ver1_num=0
		else
			ver1_num=`yxct_math_short ${ver1_num}`
		fi
		
		local ver2_num=${ver2[i]}
		if [[ -z ${ver2_num} ]]; then
			ver2_num=0
		else
			ver2_num=`yxct_math_short ${ver2_num}`
		fi
		
		
		if [[ "${ver1_num}" > "${ver2_num}" ]]; then
			return 1
		elif [[ "${ver1_num}" < "${ver2_num}" ]]; then
			return 2
		fi
		
	done
	
	return 0
}


function yxct_strvercmp_bash () {
	
	if [[ $1 == $2 ]]; then
		return 0
	fi
	
	local IFS=.
	local i ver1=($1) ver2=($2)
	
	# fill empty fields in ver1 with zeros
	for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
		ver1[i]=0
	done
	
	for ((i=0; i<${#ver1[@]}; i++)); do
		
		if [[ -z ${ver2[i]} ]]; then
			# fill empty fields in ver2 with zeros
			ver2[i]=0
		fi
		
		local ver1_num=${ver1[i]}    
		if [[ -z ${ver1_num} ]]; then
			ver1_num=0
		else
			ver1_num=`yxct_math_short ${ver1_num}`
		fi
		
		local ver2_num=${ver2[i]}
		if [[ -z ${ver2_num} ]]; then
			ver2_num=0
		else
			ver2_num=`yxct_math_short ${ver2_num}`
		fi
		
		if [[ "${ver1_num}" > "${ver2_num}" ]]; then
			return 1
		elif [[ "${ver1_num}" < "${ver2_num}" ]]; then
			return 2
		fi

		
	done
	return 0
}

# 用于比较版本号
function yxct_strvercmp () {
	
	local result=
	
	if [[ $(yxct_shell_type) == 'zsh' ]]; then
		setopt sh_word_split
		yxct_strvercmp_zsh $@
		result=$?
		unsetopt sh_word_split
	else
		yxct_strvercmp_bash $@
		result=$?
	fi
	
	return ${result}
}

###########################################################
# config
###########################################################

function _yxct_sed_escape() {
  sed -e 's/[][\/^$?*.]/\\&/g'
}

function _yxct_grep_escape() {
  sed -e 's/[][\/^$?+*.]/\\&/g' 
}

function yxct_config_read()
{

  local file=
  local key=

  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
    --file )
      cursor=$1
      shift
      file=$1
    ;;

    --key )
      cursor=$1
      shift
      key=$1
    ;;

    *)
      if [[ "${cursor}" == '--file' ]]; then
        file="${file} $1"
      elif [[ "${cursor}" == '--key' ]]; then
        key="${key} $1" 
      else
        yxct_fatal "Invalid optional ${1}"
      fi
    ;;
    esac
    shift
  done

  if [ -z "${key}" ]; then
    yxct_fatal 'key is empty'
  fi

  if [ -z "${file}" ]; then
    yxct_fatal 'file is empty'
  fi


  local sed_fixkey=$(echo "${key}" | _yxct_sed_escape)
  local grep_fixkey=$(echo "${key}" | _yxct_grep_escape)
  test -f "${file}" && grep -E "^\s*${grep_fixkey}\s*=\s*" "${file}" | sed -e  "s/[[:space:]]*${sed_fixkey}[[:space:]]*=[[:space:]]*//g" | grep -o "[^ ]\+\( \+[^ ]\+\)*"
}


function yxct_config_write()
{

  local file=
  local key=
  local val=
  local space=' '
  local nospace=false
  local duplicate=false

  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
    --file )
      cursor=$1
      shift
      file=$1
    ;;

    --key )
      cursor=$1
      shift
      key=$1
    ;;

    --val )  
      cursor=$1
      shift
      val=$1
    ;;

    --no-space )
      # A = B 还是 A=B
      # 如果部分配置文件，不允许等号两旁优空格
      # 使用 --no-space
      cursor=
      nospace=true
    ;;

    --duplicate-key )
      # Key 是否可以重复。
      # 如果当存在 A = 2 时， 写入 A = 3
      # 默认行为是将 A = 2 替换为 A = 3
      # 当使用 --dupliate-key 参数时 
      # 会在 A = 2 下面 添加 A = 3.
      cursor=
      duplicate=true
    ;;


    *)
    if [[ "${cursor}" == '--file' ]]; then
        file="${file} $1"
      elif [[ "${cursor}" == '--key' ]]; then
        key="${key} $1" 
    elif [[ "${cursor}" == '--val' ]]; then
        val="${val} $1" 
      else
        yxct_fatal "Invalid optional ${1}"
      fi
    ;;
    esac
    shift
  done


  if [ -z "${key}" ]; then
    yxct_fatal 'key is empty'
  fi

  if [ -z "${val}" ]; then
    yxct_fatal 'val is empty'
  fi

  if [ -z "${file}" ]; then
    yxct_fatal 'file is empty'
  fi

  # 部分配置文件，不允许等号两旁有空格
  if ${nospace}; then
    space=''
  fi


  local sed_fixkey=$(echo "${key}" | _yxct_sed_escape)
  local grep_fixkey=$(echo "${key}" | _yxct_grep_escape)

  local sed_fixval=$(echo "${val}" | _yxct_sed_escape)
  local grep_fixval=$(echo "${val}" | _yxct_grep_escape)

  if test -f "${file}" &&  grep -Eq "^\s*${grep_fixkey}\s*=\s*${grep_fixval}\s*$" "${file}"; then # Testfile exist and text 'key = val' exist, do nothing ...
    :
  elif test -f "${file}" && grep -Eq "^\s*${grep_fixkey}\s*=.*$" "${file}"; then #Test file exist and text 'key = xxx' exist
    if ${duplicate}; then
      if [[ $(yxct_os_type) == 'osx' ]]; then
        # 因为sed在OSX上的问题，这里不得不换行!!!
        sed -i "" "/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
        ${sed_fixkey} = ${sed_fixval}\\
        " "${file}"
      else
        sed -i "/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${sed_fixval}" "${file}"
      fi
    else
      if [[ $(yxct_os_type) == 'osx' ]]; then
        sed -i "" "s/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      else
        sed -i "s/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      fi
    fi
  elif test -f "${file}" && grep -Eq "^\s*#\s*${grep_fixkey}\s*=.*$" "${file}"; then #Test file exist and text '# key = xxx' exist
    if   grep -Eq "^\s*#\s*${grep_fixkey}\s*=\s*${grep_fixval}\s*$" "${file}"; then #Test exist '# key = val', remove '#' and format line.
      if [[ $(yxct_os_type) == 'osx' ]]; then
        sed -i "" "s/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      else
        sed -i "s/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      fi
    else # Text '# key=???' exist, append 'key = val' below.
        ##############################################################################################
      # 这里有个Bug, 当sed 使用 'a' 追加模式时， 如果同时使用了 "复杂的正则表达式" 和 "限定匹配次数"。
      # 正则和限定次数逻辑都会失效，并匹配文件每一行。
      # 好在这种情况比较少见，暂时不做处理。(没想到怎么处理...)
        ##############################################################################################
      if [[ $(yxct_os_type) == 'osx' ]]; then
          # 因为sed在OSX上的问题，这里不得不换行!!!
        # sed -i "" "0,/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
        # ${sed_fixkey} = ${sed_fixval}\\
        # " "${file}"
        sed -i "" "/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
        ${sed_fixkey} = ${sed_fixval}\\
        " "${file}"
      else
        # sed -i "0,/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${sed_fixval}" "${file}"
        sed -i "/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${sed_fixval}" "${file}"
      fi
    fi
  else
    echo -e "\n\n${key}${space}=${space}${val}\n" >> "${file}"
  fi  
}

function yxct_config_allkeys()
{
  
  local file=
  
  while [ $# -gt 0 ]; do
    case $1 in
      --file )
        shift
        file=$1
      ;;
      
      *)
        yxct_fatal "Invalid optional ${1}"
      ;;
    esac
    shift
  done
  
  
  if [ -z "${file}" ]; then
    yxct_fatal 'file is empty'
  fi
  
  if [ -f "${file}" ]; then
    while read line; do
      echo ${line} | sed -e "s/^[[:space:]]*\(.*\)[[:space:]]*=.*$/\1/g" | grep -o "[^ ]\+\( \+[^ ]\+\)*"
    done < "${file}"
  fi
  
}



###########################################################
# Utility
###########################################################

function yxct_get_library_path()
{
  local lib_path=
  if [[ $(yxct_os_type) == 'osx' ]]; then
    lib_path="/usr/local/yuxi"
  else
    lib_path="/usr/yuxi"
  fi

  echo "${lib_path}"
}

function yxct_get_default_cache_path()
{
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi

  echo "${library_path%\/}/${CMD}/cache"
}

function yxct_get_cmd_item()
{
  local type=
  while [ $# -gt 0 ]; do
    case $1 in
      
      --cache )
       type=$1
      ;;

      --config )
       type=$1
      ;;

      --index )
       type=$1
      ;;

      --index-repo )
       type=$1
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done

  # get cellar_path
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi

  local result=0
  if [[ "${type}" == '--cache' ]]; then
    result="${library_path%\/}/${CMD}/cache"
  elif [[ "${type}" == '--config' ]]; then
    result="${library_path%\/}/${CMD}/conf"
  elif [[ "${type}" == '--index' ]]; then
    result="${library_path%\/}/${CMD}/index"
  elif [[ "${type}" == '--index-repo' ]]; then

    local index_path=$(yxct_get_cmd_item --index)
    if [ -z "${index_path}" ]; then
      yxct_fatal "failed to get index path"
    fi

    # git addr
    local git_addr=$(cmd_config read --key index.repo)
    if [ -z "${git_addr}" ]; then
      git_addr="${YXCT_INDEX_DEFAULT_GIT_ADDR}"
    fi

    # branch
    local git_branch=$(cmd_config read --key index.branch)
    if [ -z "${git_branch}" ]; then
      git_branch="${YXCT_INDEX_DEFAULT_GIT_BRANCH}"
    fi

    # repo folder name
    local index_dir_name=
    if [[ $(yxct_os_type) == 'osx' ]]; then
      index_dir_name=$(echo "${git_addr}#${git_branch}" | md5)
    else
      index_dir_name=$(echo "${git_addr}#${git_branch}" | md5sum | awk '{print $1}')
    fi

    # repo dir
    result="${index_path%\/}/${index_dir_name}"
  fi
  
  echo "${result}"
  [ -n "${result}" ] && return 0 || return 1
}


#usage
# yxct_git_repo update --repo <repo-path> --addr <git-addr>
#usage
# yxct_git_repo checkout <git-hash> --repo <repo-path> --addr <git-addr>
#usage
# yxct_git_repo info --repo <repo-path> [--repo|--addr|--head]
#
# return value
# update:
# 0:success
# 11:already the last version
# checkout
# 0:success
# 
#
# 这个函数，需要重写！！！
function yxct_git_repo()
{
  local repo_path=
  local git_address=
  local git_hash=
  local git_branch=

  local file=
  local work_tree=

  #operation 为 info 时使用
  local info=

  local operation=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    if yxct_strcontains "$1" 'checkout' --ignorecase; then
      operation='CHECKOUT'
      if [ -n "$2" ] && [[ "$2" =~ ^[0-9a-zA-z]{7,40}$ ]]; then
        git_hash=$2
        shift
      fi
    elif yxct_strcontains "$1" 'update' --ignorecase; then
      operation='UPDATE'
    elif yxct_strcontains "$1" 'info' --ignorecase; then
      operation='INFO'
    else
      operation=$1
    fi
    shift
  fi



  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
      --repo )
        cursor=$1
        if [ -z "${info}" ]; then
          # 因为 --repo 参数必须有，所以只有在没指定其他info类型时，info才是--repo
          info=$1
        fi
      ;;

      --addr )
        cursor=$1
        info=$1
      ;;

      --branch )
        cursor=$1
        info=$1
      ;;

      --all-branch-local )
        cursor=$1
        info=$1
      ;;

      --all-branch-remote )
        cursor=$1
        info=$1
      ;;

      --all-branch )
        cursor=$1
        info=$1
      ;;

      --file )
        shift
        file=$1
      ;;

      --work-tree )
        shift
        work_tree=$1
      ;;

      --head )
        cursor=
        info=$1
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--repo' ]]; then
            repo_path=$(echo "${repo_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--addr' ]]; then
            git_address=$(echo "${git_address} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--branch' ]]; then
            git_branch=$(echo "${git_branch} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yxct_fatal "invalid optional ${1}"
        fi
    esac
    shift
  done

  if [ -z "${repo_path}" ]; then
    yxct_fatal "repo path is empty"
  fi

  # yxct 预计的环境，很大可能是没有git的...
  if ! which git > /dev/null; then
    yxct_fatal "can not find git command."
  fi


  function __yxct_default_branch()
  {
    local branch=
    for name in main master; do
      local output=$(git -C "${repo_path}" branch | grep ${name})
      if [ -n "${output}" ]; then
        branch="${name}"
        break
      fi
    done

    echo "${branch}"
  }


  function __yxct_valid_repo()
  {
    local git_addr=$1
    local valid=true

    # check the directory is a git repo.
    if ${valid}; then
      if ! [ -d "${repo_path}" ]; then
        valid=false
      elif ! [ -d "${repo_path}/.git" ]; then
        valid=false
      elif ! git -C "${repo_path}" rev-parse --git-dir &> /dev/null; then
        valid=false
      else
        local git_flag=
        if git_flag=$(git -C "${repo_path}" rev-parse --git-dir 2> /dev/null); then
          if [[ "${git_flag}" != '.git' ]]; then
            git_flag=false
          fi
        else
          valid=false
        fi
        
      fi
    fi


    # check the git address is same with '--address params'
    if ${valid}; then
      if [ -n "${git_addr}" ]; then
        local repo_git_addr=$(git -C "${repo_path}" remote -v | grep -i '\(fetch\)' | awk '{print $2}')
        if [[ "${git_addr}" != "${repo_git_addr}" ]]; then
          valid=false
        fi
      fi
    fi

    ${valid} && return 0 || return 1
  }

  function __yxct_clean_repo()
  {
    local branch=$1

    # get repo status
    local git_status=
    if ! git_status=$(git -C "${repo_path}" status --porcelain=v1); then
      yxct_fatal "failed to get git status"
    fi

    # clean the repo if need
    if [ -n "${git_status}" ]; then
      yxct_msg "the repo is dirty, try recover..."
      
      # clean the repo
      # yxct_verbcmd "git -C ${repo_path} reset --hard origin/main"
      yxct_verbcmd "git -C ${repo_path} reset --hard HEAD --"
      yxct_verbcmd "git -C ${repo_path} clean -fd"


      # check clean result
      if ! git_status=$(git -C "${repo_path}" status --porcelain=v1); then
        yxct_fatal "failed to get git status after clean yxct repo"
      fi
      if [ -n "${git_status}" ]; then
        yxct_fatal "failed to clean ${CMD} repo"
      fi
    fi


    # make sure the right branch.
    # 如果 current_branch 为 nil, 说明时分离状态
    local current_branch=$(git -C "${repo_path}" branch --show-current)
    if [ -n "${branch}" ]; then
      # 如果给定新分支，切换到新分支
      if [ -z "${current_branch}" ]  ||  [[ "${branch}" != 'current_branch' ]]; then
        yxct_verbcmd "git -C ${repo_path} checkout ${branch}" 2> /dev/null
      fi
    else
      # 如果没有给定新分支，但当前分支是分离状态, 切换到默认分支
      if [ -z "${current_branch}" ]; then
        local default_branch=$(__yxct_default_branch)
        if [ -n "${default_branch}" ]; then
          yxct_verbcmd "git -C ${repo_path} checkout ${default_branch}"
        fi
      fi
    fi

  }

  function __yxct_clone_new_repo()
  {
    local git_addr=
    local git_branch=

    while [ $# -gt 0 ]; do
      case $1 in
        --addr )
          shift
          git_addr=$1
        ;;

        --branch )
          shift
          git_branch=$1
        ;;

        *)
          yxct_fatal "invalid optional:${1}"
      esac
      shift
    done

    # local git_addr=$1
    if [ -z "${git_addr}" ]; then
      yxct_fatal "git addr is empty"
    fi

    # remove old repo directory if exist
    if [ -d "${repo_path}" ]; then
      yxct_verbcmd "${RM} -rf ${repo_path}"
      if [ -d "${repo_path}" ]; then
        yxct_verbcmd "failed to remove old repo directory"
      fi
    fi

    # create the repo directory
    if ! yxct_verbcmd "${MKDIR} -p ${repo_path}"; then
      yxct_fatal "failed to create repo directory"
    fi

    # clone a new repo
    local branch_params=
    if [ -n "${git_branch}" ]; then
      branch_params="--branch ${git_branch}"
    fi
    if ! yxct_verbcmd "git clone ${branch_params} ${git_addr} ${repo_path}"; then
      yxct_fatal "failed to clone a new repo."
    fi
  }


  local result=0
  if [[ "${operation}" == 'CHECKOUT' ]]; then

    yxct_msg "check local git repo directory..."
    if __yxct_valid_repo "${git_address}"; then

      # git fetch
      yxct_msg "check update info..."
      yxct_verbcmd "git -C ${repo_path} fetch"

      # clean the repo
      yxct_msg "clean local repo directory..."
      __yxct_clean_repo "${git_branch}"


      # 如果存在fetch_address, 则尝试更新仓库
      local real_addr=$(yxct_git_repo info --repo "${repo_path}" --addr)
      if [ -n "${real_addr}" ]; then

        # git pull
        local git_head=$(git -C "${repo_path}" log HEAD | head -n 1 | awk '{print $2}')
        local git_fetch_head=$(git -C "${repo_path}" log FETCH_HEAD | head -n 1 | awk '{print $2}')
        if [[ "${git_head}" != "${git_fetch_head}" ]]; then
          yxct_msg "begin update..."
          #pull the repo
          if ! yxct_verbcmd "git -C ${repo_path} pull"; then
            yxct_fatal "failed to pull repo"
          fi
        fi

      fi

    else
      if [ -n "${git_address}" ]; then
        # clone a new repo
          yxct_msg "clone a new repo..."

        local branch_params=
        if [ -n "${git_branch}" ]; then
          branch_params="--branch ${git_branch}"
        fi
          
        __yxct_clone_new_repo --addr "${git_address}" ${branch_params}
      else
        yxct_fatal "git address is empty, can not clonew a new repo"
      fi
    fi

    # checkout the repo on specific git-hash.
    local git_head=$(git -C "${repo_path}" log HEAD | head -n 1 | awk '{print $2}')
    if [[ "${git_head}" != "${git_hash}" ]]; then
      yxct_msg "checkout repo HEAD to ${git_hash}..."

      work_tree_params=
      if [ -n "${work_tree}" ]; then
        work_tree_params="--work-tree ${work_tree}"
      fi

      file_params=
      if [ -n "${file}" ]; then
        file_params="-- ${file}"
      fi

      if [ -n "${git_hash}" ]; then
        # 修改 暂时没有其他办法，只能修改 advice.detachedHead config,
        local ori_detachedHead=$(git -C "${repo_path}" config advice.detachedHead)
        yxct_verbcmd "git -C ${repo_path} config advice.detachedHead false"
        # 因为这里允许错误，所以将错误信息扔掉，避免没必要的报错
        yxct_verbcmd "git -C ${repo_path} ${work_tree_params} checkout ${git_hash} ${file_params}" 2>/dev/null
        result=$?
        if [ -n "${ori_detachedHead}" ]; then
          if [[ "${ori_detachedHead}" != 'false' ]]; then
            yxct_verbcmd "git -C ${repo_path} config advice.detachedHead ${ori_detachedHead}"
          fi
        else
            yxct_verbcmd "git -C ${repo_path} config --unset advice.detachedHead"
        fi
      elif [ -n "${git_branch}" ]; then
        # 因为这里允许错误，所以将错误信息扔掉，避免没必要的报错
        yxct_verbcmd "git -C ${repo_path} ${work_tree_params} checkout ${git_branch} ${file_params}" 2>/dev/null
        result=$?
      fi
    fi

  elif [[ "${operation}" == 'UPDATE' ]]; then
    
    yxct_msg "check local git repo directory..."
    if __yxct_valid_repo "${git_address}"; then

      # git fetch
      yxct_msg "check update info..."
      yxct_verbcmd "git -C ${repo_path} fetch"

      # check whether need update
      local git_head=$(git -C "${repo_path}" log HEAD | head -n 1 | awk '{print $2}')
      local git_fetch_head=$(git -C "${repo_path}" log FETCH_HEAD | head -n 1 | awk '{print $2}')
      if [[ "${git_head}" != "${git_fetch_head}" ]]; then

        # clean the repo
        __yxct_clean_repo "${git_branch}"

        yxct_msg "begin update..."
        #pull the repo
        if ! yxct_verbcmd "git -C ${repo_path} pull"; then
          yxct_fatal "failed to pull repo"
        fi

        result=0
      else
        # is already the latest version"
        result=11
      fi

    else
      if [ -n "${git_address}" ]; then
        # clone a new repo
        yxct_msg "clone a new repo..."
        local branch_params=
        if [ -n "${git_branch}" ]; then
          branch_params="--branch ${git_branch}"
        fi
        if ! __yxct_clone_new_repo --addr "${git_address}" ${branch_params}; then
          yxct_fatal "failed to clone new repo"
        fi
        result=0
      else
        result=1
        yxct_fatal "git address is empty, can not clone a new repo"
      fi
    fi

  elif [[ "${operation}" == 'INFO' ]]; then
    if [[ "${info}" == '--repo' ]]; then
      if __yxct_valid_repo; then
        result=0
      else
        result=1
      fi
    elif [[ "${info}" == '--addr' ]]; then
      if __yxct_valid_repo; then
        local repo_git_addr=$(git -C "${repo_path}" remote -v | grep -i '\(fetch\)' | awk '{print $2}')
        if [ -n "${repo_git_addr}" ]; then
          echo "${repo_git_addr}"
          result=0
        else
          result=1
        fi
      else
        result=1
      fi
    elif [[ "${info}" == '--head' ]]; then
      if __yxct_valid_repo; then
        local git_head=$(git -C "${repo_path}" log HEAD | head -n 1 | awk '{print $2}')
        if [ -n "${git_head}" ]; then
          echo "${git_head}"
          result=0
        else
          result=1
        fi
      else
        result=1
      fi
    elif [[ "${info}" == '--branch' ]]; then
      if __yxct_valid_repo; then
        local current_branch=$(git -C "${repo_path}" branch --show-current)
        if [ -n "${current_branch}" ]; then
          echo "${current_branch}"
          result=0
        else
          result=1
        fi
      else
        result=1
      fi
    elif [[ "${info}" == '--all-branch-local' ]]; then
      if __yxct_valid_repo; then
        git -C "${repo_path}" branch --show-current
        git -C "${repo_path}" branch --list | grep -E '.*' | grep -Ev "^\s*\*\s*.*$"
      fi
    elif [[ "${info}" == '--all-branch-remote' ]]; then
      if __yxct_valid_repo; then
        git -C "${repo_path}" branch --show-current
        git -C "${repo_path}" branch -r | grep -E '.*' | grep -Ev "^\s*\*\s*.*$"
      fi
    elif [[ "${info}" == '--all-branch' ]]; then
      if __yxct_valid_repo; then
        git -C "${repo_path}" branch --show-current
        git -C "${repo_path}" branch -a | grep -E '.*' | grep -Ev "^\s*\*\s*.*$"
      fi
    else
      result=1
    fi

  else
    yxct_fatal "unknown opton:${operation}"
    result=1
  fi


  return "${result}"
}


function yxct_get_cellar_item()
{
  local command=
  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "empty command on cellar item"
  fi


  local type=
  while [ $# -gt 0 ]; do
    case $1 in
      
      --setup-script )
       type=$1
      ;;

      --bin-path )
       type=$1
      ;;

      --command-hash )
       type=$1
      ;;

      --command-version )
       type=$1
      ;;

      --command-githash )
       type=$1
      ;;

      --command-gitaddr )
       type=$1
      ;;

      --cellar-path )
       type=$1
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done


  # get cellar_path
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi


  local result=0
  local cellar_path="${library_path%\/}/${CMD}/cellar/${command}"
  if [[ "${type}" == '--setup-script' ]]; then
    if [ -f "${cellar_path}/.${CMD}.setup.sh" ]; then
      echo "${cellar_path}/.${CMD}.setup.sh"
    elif [ -f "${cellar_path}/.${CMD}.setup.py" ]; then
      echo "${cellar_path}/.${CMD}.setup.py"
    elif [ -f "${cellar_path}/.${CMD}.setup.rb" ]; then
      echo "${cellar_path}/.${CMD}.setup.rb"
    else
      result=1
    fi
  elif [[ "${type}" == '--command-hash' ]]; then
    if [ -f "${cellar_path}/info" ]; then
      yxct_config_read --file "${cellar_path}/info" --key 'filehash'
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--command-version' ]]; then
    if [ -f "${cellar_path}/info" ]; then
      yxct_config_read --file "${cellar_path}/info" --key 'version'
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--command-githash' ]]; then
    if [ -f "${cellar_path}/info" ]; then
      yxct_config_read --file "${cellar_path}/info" --key 'githash'
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--command-gitaddr' ]]; then
    if [ -f "${cellar_path}/info" ]; then
      yxct_config_read --file "${cellar_path}/info" --key 'gitaddr'
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--bin-path' ]]; then
    if [ -f "${cellar_path}/info" ]; then
      yxct_config_read --file "${cellar_path}/info" --key 'dest'
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--cellar-path' ]]; then
    echo "${cellar_path}"
  else
    echo "${cellar_path}"
  fi

  return ${result}
}


function setup_cellar()
{
  local command=

  local install_script=
  local install_file=
  local cache_dir=
  local bin_path=
  local version=

  local option=
  if yxct_strcontains "$1" "install" --ignorecase; then
    option='INSTALL'
    shift
  elif yxct_strcontains "$1" "uninstall" --ignorecase; then
    option='UNINSTALL'
    shift
  elif yxct_strcontains "$1" "upgrade" --ignorecase; then
    option='UPGRADE'
    shift
  else
    yxct_fatal "unknown option in setup cellar"
  fi

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi


  while [ $# -gt 0 ]; do
    case $1 in

      --install-file )
        shift
        install_file=$1
      ;; 

      --install-script )
        shift
        install_script=$1
      ;; 

      --bin-path )
        shift
        bin_path=$1
      ;;

      --cache-dir )
        shift
        cache_dir=$1
      ;; 

      --version )
        shift
        version=$1
      ;; 

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done


  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi


  local cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)
  if [ -z "${cellar_path}" ]; then
    yxct_fatal "failed to get cellar path of command:${command}"
  fi


  if [[ "${option}" == 'INSTALL' ]]; then

    # create cellar dir
    if [ -d "${cellar_path}" ]; then
      yxct_err "cell path already exist, try remove it:${cellar_path}"
      if ! yxct_verbcmd "${RM} -rf ${cellar_path}"; then
        yxct_fatal "failed to remove old cellar dir:${cellar_path}"
      fi
    fi

    if ! yxct_verbcmd "${MKDIR} -p ${cellar_path}"; then
      yxct_fatal "failed to create dir:${cellar_path}"
    fi

    # copy file
    if [ -n "${install_script}" ]; then
      if [ -f "${install_script}" ]; then
        yxct_verbcmd "${CP} ${install_script} ${cellar_path}"
      else
        yxct_fatal "can not find a install script on setup cellar"
      fi
    fi

    # write information to info file

    # write file hash
    local info_file="${cellar_path}/info"
    if [ -n "${install_file}" ]; then
      if [ -f "${install_file}" ]; then
        local install_file_hash=$(shasum -a 256 "${install_file}" | awk '{print $1}')
        if [ -n "${install_file_hash}" ]; then
          yxct_config_write --file "${info_file}" --key "filehash" --val "${install_file_hash}"
        else
          yxct_fatal "failed to calculate the hash value on install file:${install_file}"
        fi
      else
        yxct_fatal "can not find a install file on setup cellar"
      fi
    fi


    local git_hash=
    local git_addr=
    if [ -n "${cache_dir}" ]; then
      local command_repo="${cache_dir%\/}/${command}"
      if [ -d "${command_repo}" ]; then

        # write git hash
        git_hash=$(yxct_git_repo info --repo "${command_repo}" --head)
        if [ -n "${git_hash}" ]; then
          yxct_config_write --file "${info_file}" --key "githash" --val "${git_hash}"
        fi

        # write git addr
        git_addr=$(yxct_git_repo info --repo "${command_repo}" --addr)
        if [ -n "${git_addr}" ]; then
          yxct_config_write --file "${info_file}" --key "gitaddr" --val "${git_addr}"
        fi

      fi
    fi

    # write version
    if [ -n "${version}" ]; then

      if yxct_strcontains "${version}" "head current" --ignorecase; then
        : # version 是 head 和 current 时， 不记录
      elif yxct_strcontains "${version}" "latest" --ignorecase; then
        # version 是 latest时，通过index.conf获取真正的版本号
        version=$(search_in_index "${command}" --key 'latest')
        if [ -n "${version}" ]; then
          yxct_config_write --file "${info_file}" --key "version" --val "${version}"
        fi
      else
        yxct_config_write --file "${info_file}" --key "version" --val "${version}"
      fi

    fi

    # bin-path
    if [ -n "${bin_path}" ]; then
      yxct_config_write --file "${info_file}" --key "dest" --val "${bin_path}"
    fi

  elif [[ "${option}" == 'UNINSTALL' ]]; then
    if [ -d "${cellar_path}" ]; then
      yxct_verbcmd "${RM} -rf ${cellar_path}"
    fi
  elif [[ "${option}" == 'UPGRADE' ]]; then

    # create cellar dir
    if [ -d "${cellar_path}" ]; then
      if ! yxct_verbcmd "${RM} -rf ${cellar_path}"; then
        yxct_fatal "failed to remove old cellar dir:${cellar_path}"
      fi
    fi

    if ! yxct_verbcmd "${MKDIR} -p ${cellar_path}"; then
      yxct_fatal "failed to create dir:${cellar_path}"
    fi

    # copy file
    if [ -n "${install_script}" ]; then
      if [ -f "${install_script}" ]; then
        yxct_verbcmd "${CP} ${install_script} ${cellar_path}"
      else
        yxct_fatal "can not find a install script on setup cellar"
      fi
    fi

    # write information to info file

    # write file hash
    local info_file="${cellar_path}/info"
    if [ -n "${install_file}" ]; then
      if [ -f "${install_file}" ]; then
        local install_file_hash=$(shasum -a 256 "${install_file}" | awk '{print $1}')
        if [ -n "${install_file_hash}" ]; then
          yxct_config_write --file "${info_file}" --key "filehash" --val "${install_file_hash}"
        else
          yxct_fatal "failed to calculate the hash value on install file:${install_file}"
        fi
      else
        yxct_fatal "can not find a install file on setup cellar"
      fi
    fi


    local git_hash=
    local git_addr=
    if [ -n "${cache_dir}" ]; then
      local command_repo="${cache_dir%\/}/${command}"
      if [ -d "${command_repo}" ]; then

        # write git hash
        git_hash=$(yxct_git_repo info --repo "${command_repo}" --head)
        if [ -n "${git_hash}" ]; then
          yxct_config_write --file "${info_file}" --key "githash" --val "${git_hash}"
        fi

        # write git addr
        git_addr=$(yxct_git_repo info --repo "${command_repo}" --addr)
        if [ -n "${git_addr}" ]; then
          yxct_config_write --file "${info_file}" --key "gitaddr" --val "${git_addr}"
        fi

      fi
    fi

    # write version
    if [ -n "${version}" ]; then

      if yxct_strcontains "${version}" "head current" --ignorecase; then
        : # version 是 head 时， 不记录
      elif yxct_strcontains "${version}" "latest" --ignorecase; then
        # version 是 latest时，通过index.conf获取真正的版本号
        version=$(search_in_index "${command}" --key 'latest')
        if [ -n "${version}" ]; then
          yxct_config_write --file "${info_file}" --key "version" --val "${version}"
        fi
      else
        yxct_config_write --file "${info_file}" --key "version" --val "${version}"
      fi

    fi

    # bin-path
    if [ -n "${bin_path}" ]; then
      yxct_config_write --file "${info_file}" --key "dest" --val "${bin_path}"
    fi

  else
    yxct_fatal "unknown option:${option}"
  fi

}

function yxct_set_info_level()
{
  local info_level=$1
  if [ -n "${info_level}" ]; then

    if ${YXCT_USEYXLIB}; then
      yx_logger set --output-level "${info_level}"
    fi

    if yxct_str_checkfmt '^([0-9])+$' "${info_level}"; then
      YXCT_DEFAULT_LEVEL="${info_level}"
      export YXLOGGER_DEFAULT_LEVEL="${info_level}"
    elif yxct_strcontains "${info_level}" 'silent' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_SILENT}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_SILENT}"
    elif yxct_strcontains "${info_level}" 'fatal fat' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_FATAL}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_FATAL}"
    elif yxct_strcontains "${info_level}" 'error err' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_ERROR}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_ERROR}"
    elif yxct_strcontains "${info_level}" 'warning warn' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_WARN}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_WARN}"
    elif yxct_strcontains "${info_level}" 'info msg' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_INFO}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_INFO}"
    elif yxct_strcontains "${info_level}" 'verbose verb' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_VERBOSE}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_VERBOSE}"
    elif yxct_strcontains "${info_level}" 'debug' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_DEBUG}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_DEBUG}"
    elif yxct_strcontains "${info_level}" 'trace' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_TRACE}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_TRACE}"
    elif yxct_strcontains "${info_level}" 'all' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_ALL}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_ALL}"
    else
      yxct_fatal "unknown info level :${info_level}"
    fi # end of (if yx_check_strfmt '^([0-9])+$' "${info_level}"; then)

  fi # end of 'if [ -n ${info_level} ]'
}


function is_in_reg_list()
{
  local name=$1
  shift
  local reg_list=($@)
  
  if [[ "${reg_list}" ]]; then
    for reg in "${reg_list[@]}"; do
      reg=$(echo "${reg}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
      if echo "${name}" | grep -Eqi "${reg}"; then
        return 0
      fi
    done
  fi
  
  return 1
}


# 如果目录下只有一个文件，则返回
# 1. 会忽略 IGNORE_LIST 列表里正则对应的文件
# 2. 会忽略 --ignore 参数中正则列表对应的文件
# usage: file_name_if_single <目录>
# usage: file_name_if_single <目录> --ignore '正则1' '正则2' ....
function file_name_if_single()
{
  local script_path=$1
  local -a ignore_reg_list
  if [[ $2 == '--ignore' ]]; then
    shift # ignore $1
    shift # ignore --ignore
    ignore_reg_list=($@)
  fi

  
  local -a valid_files
  # local SAVEIFS=$IFS
  for file in "${script_path%\/}"/*; do

    if [[ ${file} =~ ^"${script_path%\/}"/*$ ]]; then
      continue
    fi

    local filename=$(basename  "${file}")    

    # 文件名在忽略列表里
    if is_in_reg_list "${filename}" ${ignore_reg_list[@]}; then
      continue
    fi

    if ! is_in_reg_list "${filename}" ${IGNORE_LIST[@]}; then
      valid_files=(${valid_files[@]} "${filename}")
    fi
    
  done
  # IFS=${SAVEIFS}
  
  if [[ "${#valid_files[@]}" == 1 ]]; then
    echo "${valid_files[@]}"
    return 0
  else
    return 1
  fi
}

function search_file_by_reg_list()
{
  local script_path=$1
  shift
  local reg_list=($@)

  # local SAVEIFS=$IFS


  # search regular files
  for file in "${script_path%\/}"/*; do

    if [[ ${file} =~ ^"${script_path%\/}"/*$ ]]; then
      continue
    fi

    local filename=$(basename "${file}")    
    if is_in_reg_list "${filename}" ${reg_list[@]}; then
      echo "${filename}"
      return 0
    fi
  done

  # search regular invisiable files 
  for file in "${script_path%\/}"/.*; do
    if [[ ${file} == ${script_path%/}/\* ]]; then
      continue
    fi

    local filename=$(basename "${file}")    
    if [[ ${filename} == '.' ]] || [[ ${filename} == '..' ]]; then
      continue
    fi

    if is_in_reg_list "${filename}" ${reg_list[@]}; then
      echo "${filename}"
      return 0
    fi
  done


  # IFS=${SAVEIFS}

  return 1
}


# function is_same_file()
# {
#   local file1=$1
#   local file2=$2

#   local file1_hash=
#   if [ -r "${file1}" ]; then
#     file1_hash=$(shasum -a 256 "${file1}")
#   fi

#   local file2_hash=
#   if [ -r ${file2} ]; then
#     file2_hash=$(shasum -a 256 "${file2}")
#   fi

#   if [[ -f "${file1}" ]] && [[ -f "${file2}" ]]; then
#     if [[ "${file1}" -eq "${file2}" ]]; then
#       return 0
#     fi
#   fi

#   return 1
# }


function check_file_hash()
{
  local file=$1
  local hash=$2

  if ! [ -r "${file}" ]; then
    yxct_fatal "Can not read the file:${file}"
  fi

  if [ -z "${hash}" ]; then
    yxct_fatal "hash is empty."
  fi

  local file_hash=$(shasum -a 256 "${file}" | awk '{print $1}')
  if [[ "${file_hash}" == "${hash}" ]]; then
    return 0
  else
    return 1
  fi
}

# 执行卸载脚本
function run_setup_script()
{
  local script_path=
  local bin_path=
  local additional=
  local all=false

  local option=$1
  if yxct_strcontains "${option}" 'install' --ignorecase; then
    option="install"
    shift
  elif yxct_strcontains "${option}" 'uninstall' --ignorecase; then
    option="uninstall"
    shift
  elif yxct_strcontains "${option}" 'upgrade' --ignorecase; then
    option="upgrade"
    shift
  else
    yxct_fatal "option is empty."
  fi

  while [ $# -gt 0 ]; do
    case $1 in
      --path )
        shift
        script_path=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --all )
        all=true
      ;;


      *)
        additional="${additional} $1"
    esac
    shift
  done


  if ! [ -f "${script_path}" ]; then
    yxct_fatal "setup script not exist :${script_path}"
  fi
  
  if ! [ -x "${script_path}" ]; then
    yxct_err "Setup script does not have execution permissions. try add one."
    yxct_verbcmd "chmod +x ${script_path}"
  fi

  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi


  # 因为运行脚本，很可能使用了YXLib库，这里让运行脚本
  # 这里了设置yxlogger的环境变量
  local saved_yxlib_log_echo_level="${YXLOGGER_DEFAULT_LEVEL}"
  if [ -n "${YXCT_DEFAULT_LEVEL}" ]; then
    # 保存之前的环境变量
    export YXLOGGER_DEFAULT_LEVEL="${YXCT_DEFAULT_LEVEL}"
  fi


  local result
  if [ -n "${bin_path}" ]; then
  # 如果给了bin_path, 则按照 bin_path 给卸载脚本
    pushd $(dirname "${script_path}") > /dev/null
    yxct_run_script "${script_path} ${option} --bin-path ${bin_path} --lib-path ${library_path} ${additional}"
    result="$?"
    popd > /dev/null

    if [[ "${result}" != '0' ]]; then
      yxct_fatal "Failed to run setup script: ${script_path}"
    fi
  elif which "${command}" > /dev/null; then
  # else
  # 如果能找到 command, 根据command获得bin-path
    while true; do

      local finded_exec_path=$(which "${command}")
      if [ -z "${finded_exec_path}" ]; then
        break
      fi
      
      local bin_path=$(dirname "${finded_exec_path}")

      pushd $(dirname "${script_path}") > /dev/null
      yxct_run_script "${script_path} ${option} --bin-path ${bin_path} --lib-path ${library_path} ${additional}"
      result="$?"
      popd > /dev/null    

      if [[ "${result}" != '0' ]]; then
        yxct_fatal "Failed to run setup script: ${script_path}"
      fi

      if ! ${all}; then
        break
      fi
    done
  
  else
    # 如果没找到command, 完全不知道 --bin-path , 直接调用脚本
    pushd $(dirname "${script_path}") > /dev/null
    yxct_run_script "${script_path} ${option} --lib-path ${library_path} ${additional}"
    result="$?"
    popd > /dev/null

    if [[ "${result}" != '0' ]]; then
      yxct_fatal "Failed to run setup script: ${script_path}"
    fi
  fi


  # 这里要还原 YXLOGGER_DEFAULT_LEVEL
  # 使用和备份时相同的判断条件
  if [ -n "${YXCT_DEFAULT_LEVEL}" ]; then
    export YXLOGGER_DEFAULT_LEVEL="${saved_yxlib_log_echo_level}"
  fi



  # pushd $(dirname "${script_path}") > /dev/null
  # yxct_run_script "${script_path} ${option} ${additional}"
  # result="$?"
  # popd > /dev/null

  # if [[ "${result}" != '0' ]]; then
  #   yxct_fatal "Failed to run setup script: ${script_path}"
  # fi

  return ${result}
}

# 根据命令名直接卸载可执行文件
# 如果有安装(cellar中有记录), library 和 record-hash , 匹配上一个就删除
# 如果没有安装(cellar中有记录), 直接删除
function remove_command()
{
  local all=false
  local command=
  local hash=

  while [ $# -gt 0 ]; do
    case $1 in
      --command )
        shift
        command=$1
      ;; 

      --hash )
        shift
        hash=$1
      ;; 

      --all )
        all=true
      ;; 
    esac
    shift
  done

  if [ -z "${command}" ]; then
    yxct_fatal "Command is empty !"
  fi


  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi
  library_path="${library_path}/${command}"


  # 提前额外验证一下， while循环里的验证不能抱错误警告
  if ! $(which "${command}" > /dev/null); then
    yxct_fatal "Can not find the command:${command}"
  fi

  # 循环删除时只报error, 确保后续删除操作继续
  while true; do
    local finded_exec_path=$(which "${command}")
    if [ -z "${finded_exec_path}" ]; then
      break
    fi

    if ! [ -w "${finded_exec_path}" ]; then
     yxct_err "have not enough permission to remove the file:${finded_exec_path}"
     continue
    fi

    if [ -h "${finded_exec_path}" ]; then
      # 如果找到的文件是一个链接，需要判断一下链接指向。
      # 如果不是指向library, 则需要报一个警告，说明原文件不会被删除
      local bin_path_source=$(readlink "${bin_path}")
      if [ -n "${bin_path_source}" ]; then
        # 如果连接指向的原文件在librray目录下
        if ! yxct_is_subpath "${library_path}" "${bin_path_source}"; then
          yxct_warn "dest file is a link. ${CMD} will deletes the link, but the original file to which the link points is still there.You can choose to delete this file manually:${bin_path_source}"
        fi
      fi
    else
      # 如果找到的文件是一个文件，直接验证hash就行
      if [ -n "${hash}" ]; then
        if ! check_file_hash "${finded_exec_path}" "${hash}"; then
          yxct_err "failed to check command's hash value:${finded_exec_path}"
          continue
        fi
      fi
    fi

    # 强制删除命令
    if ! yxct_verbcmd "${RM} -f ${finded_exec_path}"; then
      yxct_err "failed to remove '${command}' at path:${finded_exec_path}"
    fi

    if ! ${all}; then
      break
    fi

  done

  # remove command's library
  if ! yxct_verbcmd "${RM} -rf ${library_path}"; then
    yxct_err "failed to remove ${command}'s library:${library_path}"
  fi

  # remove setter
  setup_cellar uninstall "${command}"

  return 0
}

# 根据一个可执行文件，查找安装的命令，并卸载
# 可执行文件仅用于 hash验证
# 查找方式
# 1. which ${command}
# 2. bin_path/command 或 bin_path/$(basename command)
function remove_by_hash_file()
{
    local file_path=
    local bin_path=
    local command=
    local all=false

    while [ $# -gt 0 ]; do
      case $1 in
        --path )
          shift
          file_path=$1
        ;;

        --bin-path )
          shift
          bin_path=$1
        ;;

        --command )
          shift
          command=$1
        ;; 

        --all )
          all=true
        ;; 
      esac
      shift
    done

    if ! [ -f "${file_path}" ]; then
      yxct_fatal "File not exist :${file_path}"
    fi
    local file_hash=$(shasum -a 256 "${file_path}" | awk '{print $1}' )
    if [ -z "${file_hash}" ]; then
      yxct_fatal "Failed to calculate the hash value of the file:${file_path}"
    fi

    local filename=$(basename "${file_path}")
    # 如果提供了命令名，脚本名字和命令名必须相同
    if [ -n "${command}" ] && [ "${filename}" != "${command}" ]; then
      yxct_fatal "Filename name and command not matched."
    fi

    if [ -n "${bin_path}" ]; then

      local finded_exec_path=
      if [ -n "${command}" ]; then
        finded_exec_path="${bin_path}/${command}"
      else
        finded_exec_path="${bin_path}/${filename}"
      fi

      if ! [ -f ${finded_exec_path} ]; then
        yxct_fatal "Can not find a command at:${finded_exec_path}"
      fi

      # 要删除的文件必须和传入的文件相同
      if ! check_file_hash "${finded_exec_path}" "${file_hash}"; then
        yxct_fatal "Script and execute file not matched:(${execute_file_path})"
      fi

      # 强制删除命令
      yxct_verbcmd "${RM} -f ${execute_file_path}"
      if [[ $? != 0 ]]; then
        yxct_fatal "Fail to uninstall '${command}' in path:${bin_path}"
      fi
   else
     local params=''
     if "${all}"; then
       arams="${params} --all"
     fi

     remove_command --command "${filename}" --hash "${file_hash}" ${params}
   fi
}


function install_file()
{
  local file_path=
  local bin_path=
  local command=
  local force=false

  while [ $# -gt 0 ]; do
    case $1 in
      --file )
        shift
        file_path=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --command )
        shift
        command=$1
      ;;

      --force )
        force=true
      ;;
    esac
    shift
  done

  if [ -z "${file_path}" ]; then
    yxct_fatal "file path is empty."
  fi

  if ! [ -r "${file_path}" ]; then
    yxct_fatal "Can not read file:${file_path}"
  fi

  if [ -z "${command}" ]; then
    command=$(basename "${file_path}")
  fi

  if [ -z "${bin_path}" ]; then
    yxct_fatal "destination path is empty."
  fi
  local dest_path="${bin_path}/${command}"

  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi
  library_path="${library_path}/${command}"


  # 当没有指定'--force' 参数，且任何目标文件已存在时，需要报错
  # 报错会自动忽略目标文件相同的情况。确保重复安装相同command时，不需要指定 '--force'
  if ! ${force}; then

    if [ -d "${library_path}" ]; then

      # 判断 library 中的文件，并验证hash. library 中的文件hash必须与要安装文件的hash相同，否则报错
      local command_name=$(file_name_if_single "${library_path}")
      local file_hash=$(shasum -a 256 "${file_path}" | awk '{print $1}')
      if [ -z "${command_name}" ] || ! check_file_hash "${library_path}/${command_name}" "${file_hash}"; then
        yxct_fatal "file already exist on library path:${library_path}. Use --force to overwrite the exist file."
      fi

      # bin-path 的文件必须是一个连接文件，且这个连接文件必须指向library中的文件. 否则报错.
      if [ -h "${dest_path}" ]; then
        local dest_link_source=$(readlink "${dest_path}")
        if [ -n "${dest_link_source}" ]; then
          if [[ "${dest_link_source}" != "${library_path}/${command_name}" ]]; then
            yxct_fatal "file already exist on dest path:${dest_path}. Use --force to overwrite the exist file."
          fi
        fi
      elif [ -e "${dest_path}" ]; then
        yxct_fatal "file already exist on dest path:${dest_path}. Use --force to overwrite the exist file."
      fi

    elif [ -e "${library_path}" ]; then
      yxct_fatal "file already exist on library path:${library_path}. Use --force to overwrite the exist file."
    fi
  fi


  # remove old library file if exist.
  if ! yxct_verbcmd "${RM} -rf ${library_path}"; then
    yxct_fatal "failed to remove old library dir:${library_path}"
  fi

  # create library dir
  yxct_verbcmd "${MKDIR} -p ${library_path}"
  if ! [ -d "${library_path}" ]; then
    yxct_fatal "failed to create library directory"
  fi

  # copy command to library dir
  if ! yxct_verbcmd "${CP} -f ${file_path} ${library_path}"; then
    yxct_fatal "failed to copy command to library dir"
  fi

  # link command to bin path
  local command_name=$(basename "${file_path}")
  if ! yxct_verbcmd "${LN} -sf ${library_path}/${command_name} ${dest_path}"; then
    yxct_fatal "faild to link command to ${dest_path}"
  fi

  return 0
}


# 根据安装脚本路径，卸载可执行文件
function uninstall_by_script_path()
{
  local script_path=
  local additional=
  local bin_path=
  local command=

  local -a ignore_reg_list=
  local all=false

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in
      --path )
        shift
        script_path=$1
      ;;

      --command )
        shift
        command=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --all )
        all=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
    esac
    shift
  done

  if [ -z "${script_path}" ]; then
    yxct_fatal "Script path is empty."
  fi

  # local all_params=''
  # if "${all}"; then
  #   all_params='--all'
  # fi

  local params=''
  #--command
  if [ -n "${command}" ]; then
    params="${params} --command ${command}"
  fi

  if [ -n "${bin_path}" ]; then
    params="${params} --bin-path ${bin_path}"
  fi

  if ${all}; then
    params="${params} --all"
  fi
  

  local result=1
  if [ -f "${script_path}" ]; then
  # 如果脚本路径是一个文件

    local script_file_name=$(basename "${script_path}")
    if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
    # 如果文件是一个安装脚本, 直接调用脚本
      run_setup_script uninstall --path "${script_path}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    else
      # 如果文件不是安装脚本，尝试使用 command 和 bin_path卸载。 并用这个文件做hash验证并卸载，并删除
      remove_by_hash_file --path "${script_path}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    fi
  elif [ -d "${script_path}" ]; then
  # 如果脚本路径是一个目录
    local uninstall_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
    if [[ -n "${uninstall_script_filename}" ]]; then
    # 如果目录中找到安装脚本, 直接掉用那个安装脚本
      run_setup_script uninstall --path "${script_path%\/}/${uninstall_script_filename}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    else
    # 没找到那个安装脚本，查看是否是单脚本APP
      local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
      if [ -n "${singl_app_name}" ]; then
        # 如果文件夹下只找到一个文件，尝试使用 command 和 bin_path卸载。并使用这个文件做 hash 验证.
        remove_by_hash_file --path "${script_path%\/}/${singl_app_name}" ${params} ${additional}
        result=$?
        setup_cellar uninstall "${command}"
      else
        # 如果不是单脚本APP, 不知道如何安装
        yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to delete the command."
      fi
    fi
  else
  # 既不是文件，也不是目录，无效script_path
    yxct_fatal "Invalid script path:${script_path}"
  fi

  return "${result}"
}


# 根据可执行文件路径，卸载这个可执行文件
function uninstall_by_bin_path()
{
  local bin_path=
  local command=
  local additional=
  
  # 这个函数被调用，说明script_path 必定为空，之前判断过了

  while [ $# -gt 0 ]; do
    case $1 in
      --path )
        shift
        bin_path=$1
      ;;

      --command )
        shift
        command=$1
      ;; 

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done




  function __uninstall_by_bin_file()
  {
    local bin_file=
    while [ $# -gt 0 ]; do
      case $1 in
        --file )
          shift
          bin_file=$1
        ;;

        *)
          yxct_fatal "Invalid params:${$1}"
      esac
      shift
    done


    if [ -z "${bin_file}" ]; then
        yxct_fatal "bin-file is empty."
    fi


    # 现在command 应该不会为空了，不过还是保留逻辑严谨
    local filename=$(basename "${bin_path}")
    if [ -n "${command}" ]; then
      if [[ "${filename}" != "${command}" ]]; then
        yxct_fatal "Filename name '${filename}' and command '${command}' not matched."
      fi
    else
      command="${filename%.*}"
    fi

    # 如果 bin_path 指向文件是一个连接
    if [ -h "${bin_path}" ]; then

      local library_path=$(yxct_get_library_path)
      if [ -z "${library_path}" ]; then
        yxct_fatal "failed to get library path"
      fi
      library_path="${library_path}/${command}"

      # 对连接指向的源文件进行判断
      local bin_path_source=$(readlink "${bin_path}")
      if [ -n "${bin_path_source}" ]; then
      
        # 如果连接指向的原文件在librray目录下
        if yxct_is_subpath "${library_path}" "${bin_path_source}"; then

          # 如果记录了文件hash, 验证问价hash
          local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
          if [ -n "${cellar_hash}" ]; then
            if ! check_file_hash "${bin_path}" "${cellar_hash}"; then
              yxct_fatal "failed to check hash value for execute file:${bin_path}"
            fi
          fi

          # 删除 library 目录下的文件
          if ! yxct_verbcmd "${RM} -rf ${library_path}"; then
            yxct_fatal "failed to remove command library:${library_path}"
          fi

        else
          yxct_warn "dest file is a link. ${CMD} will deletes the link, but the original file to which the link points is still there.You can choose to delete this file manually:${bin_path_source}"
        fi
      
      else
        yxct_warn "dest file is a link. but the original file to which the linked file points does not exist. ${CMD} will deletes the link file only."
      fi

      # 删除链接
      if ! yxct_verbcmd "${RM} -f ${bin_path}"; then
        yxct_fatal "failed to remove command:${bin_path}"
      fi
    else
      #如果 bin_path 指向文件是一个普通文件
      local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
      if [ -n "${cellar_hash}" ]; then
        if ! check_file_hash "${bin_path}" "${cellar_hash}"; then
          yxct_fatal "failed to check hash value for execute file:${bin_path}"
        fi
      fi

      # 删除文件
      if ! yxct_verbcmd "${RM} -f ${bin_path}"; then
        yxct_fatal "failed to remove command:${bin_path}"
      fi
    fi
  }



  if [ -f "${bin_path}" ]; then

    __uninstall_by_bin_file --file "${bin_path}"

    # 清理 cellar
    setup_cellar uninstall "${command}"

  elif [ -d "${bin_path}" ]; then
  # 如果bin_path 是个目录, 则command 不能为空, 根据command删除

    if [ -z "${command}" ]; then
      yxct_fatal "Can not find any script in path ${bin_path}"
    fi

    local execute_file_path="${bin_path}/${command}"
    if ! [ -f "${execute_file_path}" ]; then
      yxct_fatal "Script does not exist:${execute_file_path}"
    fi

    # 删除逻辑
    __uninstall_by_bin_file --file "${execute_file_path}"

    # 把空文件夹也清理掉
    yxct_verbcmd "${RM} -rf ${bin_path}"

    setup_cellar uninstall "${command}"
  else
    # 既不是文件，也不是目录，无效bin_path
    yxct_fatal "Invalid path:${bin_path}"
  fi

  return 0
}



function search_in_index()
{
  local index_config=
  local command=
  local key=
  local all_version=false

  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi

  while [ $# -gt 0 ]; do
    case $1 in
      --key )
        shift
        key=$1
      ;;

      --index )
        shift
        index_config=$1
      ;;

      --all-version )
        all_version=true
      ;;

      *)
        yxct_fatal "Invalid params:$1"
    esac
    shift
  done

  if [ -z "${index_config}" ]; then

    local index_repo=$(yxct_get_cmd_item --index-repo)
    if [ -z "${index_repo}" ]; then
      yxct_fatal "failed to get index repo path"
    fi

    # repo dir
    index_config="${index_repo%\/}/index/${command}.conf"
  fi

  if [ -f "${index_config}" ]; then

    if ${all_version}; then
      for version in $(yxct_config_allkeys --file "${index_config}"); do
        if yxct_strcontains "${version}" "repo latest"; then
          continue
        fi
        echo "${version}"
      done
    else
      yxct_config_read --file "${index_config}" --key "${key}"
    fi
  fi
}


function update_index_if_need()
{
  # 是否强制更新
  local force_update=false
  if [ -n "${1}" ] && [[ "${1}" == '--force' ]]; then
    force_update=true
  fi

  # local need_update=false
  local index_path=$(yxct_get_cmd_item --index)
  if [ -z "${index_path}" ]; then
    yxct_fatal "failed to get index path"
  fi

  # last update timestamp
  local last_timestamp_file="${index_path}/last"


  # create the index path directory if not exist
  if ! [ -d "${index_path}" ]; then
    # need_update=true
    yxct_verbcmd "${MKDIR} -p ${index_path}"
    if ! [ -d "${index_path}" ]; then
      yxct_fatal "failed to create index directory"
    fi
  fi

  #check whether should update index repo
  local should_update=true
  # 如果不是强制更新，才会判断 should_update 选项
  if ! ${force_update}; then

    # check update flag
    if ${should_update}; then
      local update=$(cmd_config read --key index.update)
      if [ -n "${update}" ]; then
        if yxct_strcontains "${update}" "no n 0 false f" --ignorecase; then
          should_update=false
        fi
      fi
    fi #end of (if ${should_update}; then)


    # check schedule
    if ${should_update}; then

      # get schedule
      local schedule=$(cmd_config read --key index.schedule)
      if [ -z "${schedule}" ]; then
        schedule="${YXCT_INDEX_DEFAULT_SCHEDULE}"
      fi
      local schedule_in_seconds=$(yxct_datastr_to_second "${schedule}")

      # get current timestamp
      local current=$(date '+%s')
      if [ -z "${current}" ]; then
        yxct_fatal "failed to get current timestamp"
      fi

      # get last update timestamp
      if [ -f "${last_timestamp_file}" ]; then
        local last=$(cat "${last_timestamp_file}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
        if [ -z "${last}" ]; then
          : # 上次更新时间戳不存在，不需要验证
        elif [[ "${last}" =~ ^[0-9]{10}$ ]]; then
          # check schedule
          if [ $((current-last)) -lt "${schedule_in_seconds}" ]; then
            should_update=false
          fi
        else
          # 上次更新时间戳，格式不对。报个error, 然后忽略时间戳
          yxct_err "invalid last update timestamp in index repo"
        fi
      fi

    fi # end of (if ${should_update}; then)

  fi # end of ( if ! ${force_update}; then)



  if ${should_update}; then
    
    # git addr
    local git_addr=$(cmd_config read --key index.repo)
    if [ -z "${git_addr}" ]; then
      git_addr="${YXCT_INDEX_DEFAULT_GIT_ADDR}"
    fi

    # git branch
    local git_branch=$(cmd_config read --key index.branch)
    if [ -z "${git_branch}" ]; then
      git_branch="${YXCT_INDEX_DEFAULT_GIT_BRANCH}"
    fi

    # repo dir
    local repo=$(yxct_get_cmd_item --index-repo)
    if [ -z "${repo}" ]; then
      yxct_fatal "failed to get index repo path"
    fi

    # update index repo
    yxct_msg "try update indexs library ..."
    yxct_git_repo update --repo "${repo}" --addr "${git_addr}" --branch "${git_branch}"
    local result=$?
    if [[ "${result}" == '0' ]]; then
      date '+%s' > "${last_timestamp_file}"
      yxct_msg "indexs library update success"
    elif [[ "${result}" == '11' ]]; then
      date '+%s' > "${last_timestamp_file}"
      yxct_msg "indexs library is already the latest version"
    else
      yxct_fatal "update failed"
    fi

  fi # end of (if ${should_update}; then)

}


function search_in_cache()
{
  local command=$1
  shift
  local cache_path="$*"

  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi

  local result=
  if [ -d "${cache_path}" ]; then
    if [ -f "${cache_path%\/}/${command}" ] || [ -d "${cache_path%\/}/${command}" ]; then
      # cache 下, 命令安装包可以是文件或文件夹
      result="${cache_path%\/}/${command}"
    elif [ -f "${cache_path%\/}/${command}.yxct" ]; then
      # cache 下, 是 package
      result="${cache_path%\/}/${command}.yxct"
    fi
  elif [ -f "${cache_path}" ]; then
    local file_name=$(basename "${cache_path}")
    if [[ "${file_name}" == "${command}" ]] || [[ "${file_name}" == "${command}.yxct" ]]; then
      result="${cache_path}"
    fi
  fi

  echo "${result}"
}

# return value:
# 0 成功
# 1 失败: 仓库不在 indexs library 和 index.conf 控制下
# 2 失败: update failed
# 3 失败: checkout failed.
# 4 失败: unknown version of command
# 11 cache already in 'HEAD' 
function checkout_a_cache()
{
  local version=
  local githash=
  local cache_path=

  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi

  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
      --version )
        cursor=$1
      ;;

      --hash )
        cursor=$1
      ;;

      --cache-dir )
        cursor=$1
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi

        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--version' ]]; then
            version=$(echo "${version} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--hash' ]]; then
            githash=$(echo "${githash} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--cache-dir' ]]; then
            cache_path=$(echo "${cache_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yxct_fatal "invalid optional ${1}"
        fi

    esac
    shift
  done

  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi

  if [ -z "${cache_path}" ]; then
    yxct_fatal "cache directory is empty"
  fi


  # get git repo path
  local repo="${cache_path%\/}/${command}"

  local index_params=
  local result=
  if [ -n "${version}" ]  &&  yxct_strcontains "${version}" "head" --ignorecase; then

    yxct_msg "search ${command} from indexs library..."
    local gitaddr=$(search_in_index "${command}" --key 'repo')
    if [ -z "${gitaddr}" ]; then
      
      # 如果在indexs library 中，没有搜索到命令，
      # 查看缓存目录, 如果缓存目录存在，且在目录中找到了'.yxct.index.conf'
      # 那么使用这个文件当作index文件, 而不是indexs library 中的indexs
      local index_path="${repo}/.yxct.index.conf"
      if [ -f "${index_path}" ]; then

        # 只要本地.yxct.index.conf 存在，替换默认 indexs library 配置文件
        index_params="--index ${index_path}"

        # 本地仓库，可能没有 gitaddr, 这里和 indexs library 处理不一样
        gitaddr=$(search_in_index "${command}" --key 'repo' --index "${index_path}")

      else
        # 命令不在indexs library 控制下，也没有 '.yxct.index.conf' 文件
        # 则不对仓库做任何操作。 即使它是git, 即使git仓库有更改
        return 1
      fi

    fi


    # checkout the version
    if [ -n "${gitaddr}" ]; then
      addr_params="--addr ${gitaddr}"
    fi



    # 如果要checkout HEAD, 必须提供 branch name
    local gitbranch=$(search_in_index "${command}" --key 'branch' ${index_params})
    if [ -z "${gitbranch}" ]; then
      yxct_fatal "checkout to HEAD, but branch name is missed in index config"
    fi


    yxct_git_repo update --repo "${repo}" ${addr_params} --branch "${gitbranch}"
    result=$?

    if [[ "${result}" == '0' ]]; then
      yxct_msg "${command} cache updated to 'HEAD'"
    elif [[ "${result}" == '11' ]]; then
      yxct_msg "${command} cache is already in 'HEAD'"
    else
      result=2
      # yxct_err "failed to prepared cache"
    fi

  elif [ -z "${version}" ]  ||  yxct_strcontains "${version}" "current" --ignorecase; then
    result=0
  else
    

    # local githash=
    yxct_msg "search ${command} from indexs library..."
    local gitaddr=$(search_in_index "${command}" --key 'repo')
    # indexs library 必须存在 gitaddr
    # 这里用gitaddr来判断 indexs library 配置是否有效
    if [ -n "${gitaddr}" ]; then

      # 从 indexs library 配置中，获取信息
      if [ -z "${githash}" ]; then
        # get the version if --version params not provide
        if [ -z "${version}" ]  ||  yxct_strcontains "${version}" "latest" --ignorecase; then

          version=$(search_in_index "${command}" --key 'latest')
          if [ -z "${version}" ]; then
            yxct_fatal "failed to get latest version:${version} of command:${command}"
          fi

          # get git-has with the 'version'
          githash=$(search_in_index "${command}" --key "${version}")
        fi 
      fi

    else
      # 到这里，说明 indexs library 中不存在 command..
      # 查看缓存目录, 如果缓存目录存在，且在目录中找到了'.yxct.index.conf'
      # 那么使用这个文件当作index文件, 而不是indexs library 中的indexs
      yxct_msg "search ${command} from local cache..."
      local index_path="${repo}/.yxct.index.conf"
      if [ -f "${index_path}" ]; then
        
        # 这里，如果传入了 git-hash参数， 也不再继续探测gitaddr
        if [ -z "${githash}" ]; then

          # get the latest version if --version params not provide
          if [ -z "${version}" ]  ||  yxct_strcontains "${version}" "latest" --ignorecase; then
            version=$(search_in_index "${command}" --key 'latest' --index "${index_path}")
          fi

          # get git-hash with the specific version
          if [ -n "${version}" ]; then
            # get git-has with the 'version'
            githash=$(search_in_index "${command}" --key "${version}" --index "${index_path}")
            if [ -n "${githash}" ]; then
              # get git-address
              gitaddr=$(search_in_index "${command}" --key 'repo' --index "${index_path}")
            fi
          fi

        fi

      fi



      # 到这里，说明当前 .yxct.index.conf 中，没有要查找的版本
      # 最有可能的情况是，上次从缓存中安装了较低的版本， 然后当前仓库处于detach状态
      # 现在要遍历所有分支，查找对应的version.
      if [ -z "${githash}" ]; then

        # 创建一个tmp目录，用于临时保存 .yxct.index.conf文件
        local tmp_path=$(mktemp -d)
        if [ ! -d "${tmp_path}" ]; then
          yxct_fatal "Failed to create a temp directory"
        fi


        yxct_msg "search ${command} from branches..."
        for branch_name in $(yxct_git_repo info --repo "${repo}" --all-branch); do
          
          yxct_msg "search ${branch_name} branch..."
          # checkout the '.yxct.index.conf' file in the 'loop-branch' to tmp-path
          if ! yxct_git_repo checkout --repo "${repo}" --branch "${branch_name}" --file '.yxct.index.conf' --work-tree "${tmp_path}"; then
            continue
          fi
          index_path="${tmp_path}/.yxct.index.conf"
          if [ -f "${index_path}" ]; then

            # get the latest version if --version params not provide
            if [ -z "${version}" ]  ||  yxct_strcontains "${version}" "latest" --ignorecase; then
              version=$(search_in_index "${command}" --key 'latest' --index "${index_path}")
            fi

            # get git-hash with the specific version
            if [ -n "${version}" ]; then
              # get git-has with the 'version'
              githash=$(search_in_index "${command}" --key "${version}" --index "${index_path}")
              if [ -n "${githash}" ]; then
                # get git-address
                gitaddr=$(search_in_index "${command}" --key 'repo' --index "${index_path}")
              fi
            fi


            # break
            if [ -n "${githash}" ]; then
              break
            fi

          fi
        done
      fi


    fi


    if [ -n "${githash}" ]; then

      # checkout the version
      local addr_params=
      if [ -n "${gitaddr}" ]; then
        addr_params="--addr ${gitaddr}"
      fi


      # 这里要check-out 指定hash, 不需要branch 名字
      yxct_git_repo checkout "${githash}" --repo "${repo}" ${addr_params}
      result=$?
      if [[ "${result}" == '0' ]]; then 
        yxct_msg "${command} cached success checkout to ${githash}"
      else
        # yxct_fatal "failed to checkout ${command} cache to ${githash}"
        result=3
      fi
    else
      # yxct_err "unknown version:${version} of command:${command}"
      result=4
    fi


  fi


  return "${result}"

}


###########################################################
# Usage
###########################################################

function yxct_usage()
{
cat <<EOF
  usage: ${CMD} <sub-command> <optional>
  Manage command tool

  usage: ${CMD} <sub-command> <--help|-h>
  For detail information for sub-command.

  usage: ${CMD} --help
  For this help information

  The following sub-command are allowed:
  install:      Install a command tool.
  uninstall:    Uninstall a command tool.
  reinstall:    Reinstall a command tool.
  update:       Update to newest version of ${CMD}
  search:       Search a command
  list:         list all installed command.
  set/get:      Set or get ${CMD} config item
  pack:         Create or extra a ${CMD} package.

  Other options
  Use '${CMD} uninstall --help' show this help information
EOF
}

function yxct_usage_install()
{

  function __usage_install_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be install to'/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install
        the command to '/usr/local/bin' as default.
  
  Un-support destination options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be install to '/bin'
  --sbin                    The command will be install to '/sbin'
  --usr-bin                 The command will be install to '/usr/bin'
  --usr-local-bin           The command will be install to '/usr/local/bin'
  --usr-local-sbin          The command will be install to '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install the
        command to '/usr/local/bin' as default.
EOF
    fi
  }


cat <<EOF
  usage: ${CMD} install <command> <optional>
  Install a command

  usage: ${CMD} install --help
  Show this help information

  The following options are availiable:
  --path <path>             1. Point to an install script or a folder that contains an install script.
                            2. Point to a command file, ${CMD} will try to install the command to system.
                            3. point to ${CMD} package with a 'yxct' extension or a folder that contains
                            the package (You can create a ${CMD} package with '${CMD} pack' command, or use
                            '${CMD} pack --help' to see more information).
  --cache [path]            Command will be install from cache directory. If the --cache parameter does not
                            provide a path. ${CMD} will try to find it from 'YXCT_CACHE_PATH' environment.
                            If 'YXCT_CACHE_PATH' environment not exist, ${CMD} will use default cache directory.
                            '--cache' has a lower priority than '--path'. If a valid '--path' parameter is
                            specified, the '--cache' parameter is ignored.
  
  --version <version>       Specify the version of the installation command. If version is 'Latest', ${CMD}
                            will install the latest version of the command. If version is 'Head', ${CMD} will
                            install the HEAD commit of command git repo.
                            If '--path <path>' is indicated, the version string will be ignored.
  
  --pass <pass>             When installing through a package, if the package requires a password,
                            you can provide it with '--pass' parameter. If the package requires a password,
                            but the '--pass' parameter is not used. ${CMD} will ask for the password during
                            the installation process

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no install
                            script there. ${CMD} will not be able to determine which script to install.
                            use '--ignore' and indicate regulars expression to ignore useless files.
  
  --force                   If an existing file on bin-path, remove it.


  The following options indicate destination path:
$(__usage_install_destination_info)
  

  The following options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} install --help' show all help information
EOF
}


function yxct_usage_search()
{
cat <<EOF
  usage: ${CMD} search command [--reg] [--info-level xxx|--no-depend]
  search a command from indexs library.

  usage: ${CMD} search command --cache [cache-path] [--reg] [--info-level xxx|--no-depend]
  search a command from a local cache directory

  The following option are availiable:
  --cache [path]          ${CMD} will search from local cache directory instead of the indexs library.
                          If the '--cache' parameter does not provide a path, ${CMD} will try to find it
                          from 'YXCT_CACHE_PATH' environment.
                          If 'YXCT_CACHE_PATH' environment not exist, ${CMD} will use default cache directory.

  --reg                   Search using an extended regular expressions instead of simple string matching


  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function yxct_usage_info()
{
cat <<EOF
  usage: ${CMD} info command [--installed] [--cache [path]] [--indexs] [--info-level xxx|--no-depend]
  display the detail information of a command


  The following option are availiable:
  --installed             Display a command's install information.

  --indexs                Display detail information of a command in indexs library. 
                          You can first use the '${CMD} update' command to update the indexs library

  --cache [path]          Display cache information of a command.
                          If the '--cache' parameter does not provide a path, ${CMD} will try to find it
                          from 'YXCT_CACHE_PATH' environment.
                          If 'YXCT_CACHE_PATH' environment not exist, ${CMD} will use default cache directory.
  
  --all                   Display all above information.
  
  NOTE:
    If no display parameters are specified, ${CMD} will look for existing items in order of priority, displaying one of them.
    The priority order is: '--installed' > '--indexs' > '--cache'


  The following option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function yxct_usage_uninstall()
{

  function __usage_install_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be uninstall from '/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as target path.

  Note: If indicate a target path but the command not installed on that path, ${CMD} will do
        nothing and raise an error.
  
  Un-support target options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be uninstall from '/bin'
  --sbin                    The command will be uninstall from '/sbin'
  --usr-bin                 The command will be uninstall from '/usr/bin'
  --usr-local-bin           The command will be uninstall from '/usr/local/bin'
  --usr-local-sbin          The command will be uninstall from '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as target.

  Note: If indicate a target path but the command not installed on that path, ${CMD} will do
        nothing and raise an error.
EOF
    fi
  }

cat <<EOF
  usage: ${CMD} uninstall <command> <optional>
  Uninstall a command

  usage: ${CMD} uninstall --help
  Show this help information

  The following options are availiable:
  --path <path>             1. point to an uninstall script or a folder that contains an uninstall script.
                            2. point to a command file, ${CMD} will try to uninstall a same command on system.
                            3. point to ${CMD} package with a 'yxct' extension or a folder that contains
                            the package (You can create a ${CMD} package with '${CMD} pack' command, or use
                            '${CMD} pack --help' to see more information).
  
  --pass <pass>             When installing through a package, if the package requires a password,
                            you can provide it with '--pass' parameter. If the package requires a password,
                            but the '--pass' parameter is not used. ${CMD} will ask for the password during
                            the installation process

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no uninstall
                            script there.  ${CMD} will not be able to determine which script to uninstall.
                            Use '--ignore' and indicate regulars expression to ignore useless files.
  
  --all                     If command installed on mutiple path and not indicate a target,
                            ${CMD} will try to delete all of them.


  The following options indicate target path:
$(__usage_install_destination_info)


  The following options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information
EOF
}


function yxct_usage_reinstall()
{

  function __usage_reinstall_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be install to'/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install
        the command to '/usr/local/bin' as default.
  
  Un-support destination options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be install to '/bin'
  --sbin                    The command will be install to '/sbin'
  --usr-bin                 The command will be install to '/usr/bin'
  --usr-local-bin           The command will be install to '/usr/local/bin'
  --usr-local-sbin          The command will be install to '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install the
        command to '/usr/local/bin' as default.
EOF
    fi
  }


cat <<EOF
  usage: ${CMD} reinstall <command> <optional>
  Reinstall a command

  usage: ${CMD} reinstall --help
  Show this help information

  The following options are availiable:
  --path <path>             1. Point to an install script or a folder that contains an install script.
                            2. Point to a command file, ${CMD} will try to install the command to system.
                            3. point to ${CMD} package with a 'yxct' extension or a folder that contains
                            the package (You can create a ${CMD} package with '${CMD} pack' command, or use
                            '${CMD} pack --help' to see more information).
  
  --cache [path]            Command will be install from cache directory. If the --cache parameter does not
                            provide a path. ${CMD} will try to find it from 'YXCT_CACHE_PATH' environment.
                            '--cache' has a lower priority than '--path'. If a valid '--path' parameter is
                            specified, the '--cache' parameter is ignored.
  
  --version <version>       Specify the version of the installation command. If version is 'Latest', ${CMD}
                            will install the latest version of the command. If version is 'Head', ${CMD} will
                            install the HEAD commit of command git repo.
                            If '--path <path>' is indicated, the version string will be ignored.
  
  --pass <pass>             When installing through a package, if the package requires a password,
                            you can provide it with '--pass' parameter. If the package requires a password,
                            but the '--pass' parameter is not used. ${CMD} will ask for the password during
                            the installation process

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no install
                            script there. ${CMD} will not be able to determine which script to install.
                            use '--ignore' and indicate regulars expression to ignore useless files.
  
  --force                   If an existing file on bin-path, remove it.


  The following options indicate destination path:
$(__usage_reinstall_destination_info)
  

  The following options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} install --help' show all help information
EOF
}


function yxct_usage_update()
{
cat <<EOF
  usage: ${CMD} update [--info-level xxx]
  Fetch the newest version of ${CMD} and all formulae from GitHub using git and perform any necessary migrations.

  The following option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_config()
{
cat <<EOF
  usage: ${CMD} config get <--key domain.key> [--no-depend|--info-level]
  display a config item with specific key

  usage: ${CMD} config set <--key domain.key> <--val value> [--no-depend|--info-level]
  set a config item with specific key


  The following option are availiable:
  --key <domian.key>     key of the key-value config item.
  --val <value>          value of the key-value config item.

  Current config info:
  [domain]:index
  index.repo      The git address of indexs library repo.
  index.branch    The git branch of indexs library repo.

  index.update    A boolean value. Whether to allow the index library to be updated automatically.
                  When the index library is updated, it may increase the wait time for commands
  index.schedule  The schedule of indexs library to be checked for updates.

                  The schedule value format is:
                  (y|year|years)(mon|month|months)(d|day|days)(h|hour|hours)(m|min|minute|minutes)(s|sec|second|seconds)

                  For example: 
                  '7d' means check update for every 7 days.
                  '1mon7d4h' means check for updates once a month, seven days and four hours.



  The following option are availiable:
  --no-depend     ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level    Command output level. 
                  The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                  or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_pack()
{
cat <<EOF
  usage: ${CMD} pack <--repo-path path> <--pack-path path> [--pass xxx | --pass] [--force|--info-level]
  Create a ${CMD} installation pack from script.

  usage: ${CMD} unpack <--repo-path path> <--pack-path path> [--pass xxx | --pass] [--force|--info-level]
  Extra script from ${CMD} installation pack

  The following option are availiable:
  --pass | --pass <xxx>   It's meand the installation package requires a password, and if no password
                          parameter is provided, ${CMD} will ask for a password during
                          the packing/unpacking process
  --force                 If an existing file or directory on target path, remove it.

  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_list()
{
cat <<EOF
  usage: ${CMD} list [--info-level | --no-depend]
  List all installed command tool.

  The following option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


###########################################################
# Command
###########################################################

function cmd_install()
{
  # 因为script_path 参数指向会变
  # 这里添加 'has_path_param'参数，用以标记
  # 是否提供了 --path 参数
  local has_path_param=false
  local script_path=
  local bin_path=
  local pass=
  local -a ignore_reg_list=
  local additional=

  local use_cache=false
  local cache_path=

  local version=

  local force=false
  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        has_path_param=true
        script_path=$1
      ;;

      --cache )
        use_cache=true;
        if ! [[ "$2" =~ ^-.*$ ]]; then
          cache_path=$2
          shift
        fi
      ;;

      --version )
        shift
        version=$1
      ;;

      --force )
        force=true
      ;;

      --ignore )
        is_in_ignore=true
        # force=true
      ;;

      --pass )
        shift
        pass=$1
      ;;

      --bin )
        bin_path="${BIN_PATH}"
      ;;

      --sbin )
        bin_path="${SBIN_PATH}"
      ;;

      --usr-bin )
        bin_path="${USR_BIN_PATH}"
      ;;

      --usr-sbin )
        bin_path="${USR_SBIN_PATH}"
      ;;

      --usr-local-bin )
        bin_path="${USR_LOCAL_BIN_PATH}"
      ;;

      --usr-local-sbin )
        bin_path="${USR_LOCAL_SBIN_PATH}"
      ;;

      --custom-dest )
        shift
        bin_path=$1
      ;;

      --test )
        test=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_install
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi


    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi 

    if [ -z "${version}" ]; then
      if "${has_path_param}"; then
        version='CURRENT'
      else
        version='LATEST'
      fi
    fi

    # 确定缓存目录
    # 如果 '--cache' 参数未提供 path
    if [ -z "${cache_path}" ]; then
      
      # 获取cache, cache 路径可以为空或不存在
      # 因为后面 如果未指定'--cache'参数，可以从网络拉取
      if [ -n "${YXCT_CACHE_PATH}" ]; then
        # 如果提供了环境变量， 从环境变量中读取 cache 路径
        cache_path="${YXCT_CACHE_PATH}"
      else
        # 如果没提供环境变量，使用默认cache路径
        cache_path="$(yxct_get_default_cache_path)"
      fi
    fi


    # 确定 bin-path
    if [ -z "${bin_path}" ]; then
      bin_path="${DEFAULT_BIN_PATH}"
    fi


    # local params=''
    # # --command
    # if [ -n "${command}" ]; then
    #   params="${params} --command ${command}"
    # fi
    
    # # --bin-path
    # if [ -n "${bin_path}" ]; then
    #   params="${params} --bin-path ${bin_path}"
    # fi


    local cmd_cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)
    if ! [ -d "${cmd_cellar_path}" ]; then

      #:! STEP 1.0
      # 将 script_path 拷贝到 cache目录
      # 如果提供了 script_path, 且script 不在cache目录, 则将 script_path 拷贝到 cache 目录
      # 如果cache目录已经存在command, 则覆盖之前的.
      if [ -n "${script_path}" ]  &&  ! yxct_is_subpath "${cache_path}" "${script_path}"; then


        if [ -d "${script_path}" ]; then
        # 如果 script_path 是一个目录

          local install_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
          local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
          if [ -n "${install_script_filename}" ]  ||  [ -n "${singl_app_name}" ]; then
          # 如果找到安装脚本 或是单脚本命令, 需要将目录拷贝到cache 目录

            # 存在的话， 先删除
            local cmd_cache_path="${cache_path}/${command}"
            if [ -e "${cmd_cache_path}" ]; then
              yxct_verbcmd "${RM} -rf ${cmd_cache_path}"
            fi
            # 再创建
            yxct_verbcmd "${MKDIR} -p ${cmd_cache_path}"
            if ! [ -d "${cmd_cache_path}" ]; then
              yxct_fatal "failed to create dir:${cmd_cache_path}"
            fi
            # copy
            if ! yxct_verbcmd "${CP} -R ${script_path}/ ${cmd_cache_path}"; then
              yxct_fatal "failed to copy script dir to cache path"
            fi

            # 新的 script_path
            script_path="${cmd_cache_path}"

          else
            # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，还有多个文件，则不知道如何安装, 直接报错
            yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to install the command."
          fi

        elif [ -f "${script_path}" ]; then

          # 存在的话， 先删除
          local cmd_cache_path="${cache_path}/${command}"
          if [ -e "${cmd_cache_path}" ]; then
            yxct_verbcmd "${RM} -rf ${cmd_cache_path}"
          fi
          # 再创建
          yxct_verbcmd "${MKDIR} -p ${cmd_cache_path}"
          if ! [ -d "${cmd_cache_path}" ]; then
            yxct_fatal "failed to create dir:${cmd_cache_path}"
          fi
          # copy
          if ! yxct_verbcmd "${CP} ${script_path} ${cmd_cache_path}"; then
            yxct_fatal "failed to copy command to cache path"
          fi

          # 新的 script_path
          script_path="${cmd_cache_path}"

        else
          # 既不是文件，也不是目录，无效script_path
          yxct_fatal "Invalid script path:${script_path}"
        fi

      fi


      #:! STEP 2.0
      # 如果安装包是yxct格式，需要解压一次
      local single_file_name=$(file_name_if_single "${script_path}")
      if [ -n "${single_file_name}" ]; then

        single_file_path="${script_path%\/}/${single_file_name}"
        if [ -n "${single_file_path}" ]; then

          # 这里通过扩展名，判断文件是否是一个 package
          local package_name=$(basename "${single_file_path}")
          if [[ "${package_name##*.}" == 'yxct' ]]; then

            local tmp_path=$(mktemp -d)
            if [ ! -d "${tmp_path}" ]; then
              yxct_fatal "Failed to create a temp directory"
            fi

            # 释放package里的内容
            local pass_params=
            if [ -n "${pass}" ]; then
              pass_params="--pass ${pass}"
            fi

            YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
            if ! cmd_pack unpack --pack-path "${single_file_path}" --repo-path "${tmp_path}" --force ${pass_params}; then
              yxct_fatal "failed to unpack pakcage:${package}"
            fi
            YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

            # 更新script_path路径
            script_path="${tmp_path%\/}/${package_name%.*}"
            # 更新cache_path路径
            cache_path="${tmp_path}"

          fi # end of (if [[ "${package_name##*.}" == 'yxct' ]]; then)

        fi # end of (if [ -n "${single_file_path}" ]; then)

      fi # end of (if [ -n "${single_file_name}" ]; then)


      #:! STEP 3.0
      # 将缓存 checkout 到合适的版本
      # 这里分两种情况
      # 1. 用户使用了--path参数。因为--path指向的本地目录可能有修改。 因此尽量不更新仓库，保证本地逻辑
      # 2. 用户没使用--path参数。则优先更新cache目录
      local checkout_result=
      if ${has_path_param}; then

        # 如果使用了 --path 参数， 则先尝试 checkout 本地缓存
        # 如果 checkout 失败, 且不要求只使用缓存, 则'强制'更新 indexs library.
        # 更新后，再次 尝试 checkout.
        #
        # => checkout两次的目的是，第一次失败可能是因为command的本地缓存，没有最新的版本信息

        # 第一次checkout
        # 这里使用了--path参数，如果 ${version} 是CURRENT 或 与仓库当前version相同，则下面命令不会做任何事。这就保证了本地修改不会被清掉
        checkout_a_cache "${command}" --version "${version}" --cache-dir "${cache_path}"
        checkout_result=$?

        # 如果不要求只使用缓存
        if ! ${use_cache}; then
          # 如果checkout报错
          if [[ "${checkout_result}" != '0' ]] && [[ "${checkout_result}" != '1' ]] && [[ "${checkout_result}" != '11' ]]; then

            # 强制更新, 使用了 '--force'
            if ! update_index_if_need --force; then
              yxct_fatal "failed to update index"
            fi

            # 再次尝试 checkout, 失败报错
            checkout_a_cache "${command}" --version "${version}" --cache-dir "${cache_path}"
            checkout_result=$?
            if [[ "${checkout_result}" != '0' ]]; then
              if [[ "${checkout_result}" == '1' ]]; then
                # 正常情况, 仓库不在 indexs library 和 index.conf 控制下
                :
              elif [[ "${checkout_result}" == '2' ]]; then
                yxct_fatal "failed to update ${command}'s cache to version:${version}"
              elif [[ "${checkout_result}" == '3' ]]; then
                yxct_fatal "failed to checkout ${command}'s cache to version:${version}"
              elif [[ "${checkout_result}" == '4' ]]; then
                yxct_fatal "unknown version:${version} of command:${command}"
              fi
            fi
          fi
        else
          # 如果要求只使用缓存, 直接报错
          if [[ "${checkout_result}" != '0' ]]; then
            if [[ "${checkout_result}" == '1' ]]; then
              # 正常情况, 仓库不在 indexs library 和 index.conf 控制下
              :
            elif [[ "${checkout_result}" == '2' ]]; then
              yxct_fatal "failed to update ${command}'s cache to version:${version}"
            elif [[ "${checkout_result}" == '3' ]]; then
              yxct_fatal "failed to checkout ${command}'s cache to version:${version}"
            elif [[ "${checkout_result}" == '4' ]]; then
              yxct_fatal "unknown version:${version} of command:${command}"
            fi
          fi
        fi

      else

        # 如果未使用 --path 参数
        # 如果不要求只使用缓存, 则'尝试'更新 indexs library
        # 不论是否更新，之后尝试 checkout.

        # 如果不要求只使用缓存，尝试更新 
        if ! ${use_cache}; then
          # update indexs library
          if ! update_index_if_need; then
            yxct_fatal "failed to update index"
          fi
        fi

        #checkout, 失败报错
        checkout_a_cache "${command}" --version "${version}" --cache-dir "${cache_path}"
        checkout_result=$?
        if [[ "${checkout_result}" != '0' ]]; then
          if [[ "${checkout_result}" == '1' ]]; then
            # 正常情况, 仓库不在 indexs library 和 index.conf 控制下
            :
          elif [[ "${checkout_result}" == '2' ]]; then
            yxct_fatal "failed to update ${command}'s cache to version:${version}"
          elif [[ "${checkout_result}" == '3' ]]; then
            yxct_fatal "failed to checkout ${command}'s cache to version:${version}"
          elif [[ "${checkout_result}" == '4' ]]; then
            yxct_fatal "unknown version:${version} of command:${command}"
          fi
        fi

      fi


      # 前面的逻辑，会将安装包拷贝到cache目录。 然后让script_path指向这个路径。
      # 但如果用户没有传入--path参数，这里需要尝试在缓存中搜索命令
      if [ -z "${script_path}" ]; then
        script_path=$(search_in_cache "${command}" "${cache_path}")
        if [ -z "${script_path}" ]; then
          yxct_fatal "can not find command ${command} from cache"
        fi
      fi



      local params=''
      # --command
      if [ -n "${command}" ]; then
        params="${params} --command ${command}"
      fi
      
      # --bin-path
      if [ -n "${bin_path}" ]; then
        params="${params} --bin-path ${bin_path}"
      fi



      # 开始安装
      if [ -f "${script_path}" ]; then
      # 如果脚本路径是一个文件

        local script_file_name=$(basename ${script_path})
        if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
        # 如果文件是一个安装脚本, 直接调用脚本
          if run_setup_script install --path "${script_path}" ${params} ${additional}; then
            
            local setup_cache_params=
            if [ -n "${cache_path}" ]; then
              setup_cache_params="--cache-dir ${cache_path}"
            fi

            setup_cellar install "${command}" --install-script "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
          else
            yxct_fatal "failed on install ${command}"
          fi
        else
        # 如果文件是不是一个安装脚本

          local force_params=''
          if ${force}; then
            force_params='--force'
          fi

          if [[ "${script_file_name}" == "${command}" ]] ||  [[ "${script_file_name%.*}" == "${command}" ]]; then
          # 如果'--path'指向的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
            if install_file --file "${script_path}" "${force_params}" ${params}; then
              
              local setup_cache_params=
              if [ -n "${cache_path}" ]; then
                setup_cache_params="--cache-dir ${cache_path}"
              fi
             
              setup_cellar install "${command}" --install-file "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
            else
              yxct_fatal "failed on install ${command}"
            fi
          else
          # '--path'指向文件名与'command'不同的情况下，验证是否指定了 ‘--strict’ 参数. 没指定则强制安装文件, 并改名为command.
            if install_file --file "${script_path}" "${force_params}" ${params}; then

              local setup_cache_params=
              if [ -n "${cache_path}" ]; then
                setup_cache_params="--cache-dir ${cache_path}"
              fi

              setup_cellar install "${command}" --install-file "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
            else
              yxct_fatal "failed on install ${command}"
            fi
          fi

        fi
      elif [ -d "${script_path}" ]; then
        # 如果脚本路径是一个目录
        local install_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
        if [ -n "${install_script_filename}" ]; then
          # 如果目录中找到安装脚本, 直接掉用那个安装脚本
          local script_path="${script_path%\/}/${install_script_filename}"
          if run_setup_script install --path "${script_path}" ${params} ${additional}; then
            
            local setup_cache_params=
            if [ -n "${cache_path}" ]; then
              setup_cache_params="--cache-dir ${cache_path}"
            fi

            setup_cellar install "${command}" --install-script "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
          else
            yxct_fatal "failed on install ${command}"
          fi
        else

          local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
          if [ -n "${singl_app_name}" ]; then
          # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，只剩下一个文件

            local force_params=''
            if ${force}; then
              force_params='--force'
            fi
            
            local app_path="${script_path%\/}/${singl_app_name}"
            if [[ "${singl_app_name}" == "${command}" ]] ||  [[ "${singl_app_name%.*}" == "${command}" ]]; then
            # 如果这唯一的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
              if install_file --file "${app_path}" "${force_params}" ${params}; then

                local setup_cache_params=
                if [ -n "${cache_path}" ]; then
                  setup_cache_params="--cache-dir ${cache_path}"
                fi

                setup_cellar install "${command}" --install-file "${app_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
              else
                yxct_fatal "failed on install ${command}"
              fi
            else
            # 这唯一的文件与'command'名字不同的情况下，没指定则强制安装文件, 并改名为command.
              if install_file --file "${app_path}" "${force_params}" ${params}; then

                local setup_cache_params=
                if [ -n "${cache_path}" ]; then
                  setup_cache_params="--cache-dir ${cache_path}"
                fi

                setup_cellar install "${command}" --install-file "${app_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
              else
                yxct_fatal "failed on install ${command}"
              fi
            fi
          else
            # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，还有多个文件，则不知道如何安装, 直接报错
            yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to install the command."
          fi

        fi
      else
      # 既不是文件，也不是目录，无效script_path
        yxct_fatal "Invalid script path:${script_path}"
      fi

    else # end of (if ! [ -d "${cmd_cellar_path}" ]; then)

      yxct_msg "${command} is already installed."
      exit 1

    fi # end of (if ! [ -d "${cmd_cellar_path}" ]; then)

  fi

  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    yxct_msg "${command} install success."
  fi
}


function cmd_uninstall()
{
  local script_path=
  local bin_path=
  local pass=
  local -a ignore_reg_list=
  local additional=

  local force=false
  local all=false
  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        script_path=$1
      ;;

      --all )
        all=true
      ;;

      --pass )
        shift
        pass=$1
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --bin )
        bin_path="${BIN_PATH}"
      ;;

      --sbin )
        bin_path="${SBIN_PATH}"
      ;;

      --usr-bin )
        bin_path="${USR_BIN_PATH}"
      ;;

      --usr-sbin )
        bin_path="${USR_SBIN_PATH}"
      ;;

      --usr-local-bin )
        bin_path="${USR_LOCAL_BIN_PATH}"
      ;;

      --usr-local-sbin )
        bin_path="${USR_LOCAL_SBIN_PATH}"
      ;;

      --custom-dest )
        shift
        bin_path=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --test )
        test=true;
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_uninstall
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi


    # extra package if need
    if [ -n "${script_path}" ]; then

      # 'script_path' 指向的可能是一个package, 也可能指向一个包含package的文件夹
      local single_file_path=
      if [ -f "${script_path}" ]; then
        single_file_path="${script_path}"
      elif [ -d "${script_path}" ]; then
        local single_file_name=$(file_name_if_single "${script_path}")
        if [ -n "${single_file_name}" ]; then
          single_file_path="${single_file_path%\/}/${single_file_name}"
        fi
      fi


      # 如果找到了一个文件
      if [ -n "${single_file_path}" ]; then

        # 这里通过扩展名，判断文件是否是一个 package
        local package_name=$(basename "${single_file_path}")
        if [[ "${package_name##*.}" == 'yxct' ]]; then

          local tmp_path=$(mktemp -d)
          if [ ! -d "${tmp_path}" ]; then
            yxct_fatal "Failed to create a temp directory"
          fi
          

          # 释放package里的内容
          local pass_params=
          if [ -n "${pass}" ]; then
            pass_params="--pass ${pass}"
          fi

          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
          if ! cmd_pack unpack --pack-path "${single_file_path}" --repo-path "${tmp_path}" --force ${pass_params}; then
            yxct_fatal "failed to unpack pakcage:${package}"
          fi
          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

          # 新的script_path路径
          script_path="${tmp_path%\/}/${package_name%.*}"
        fi

      fi # end of (if [ -n "${single_file_path}" ]; then)

    fi # end of (if [ -n "${script_path}" ]; then)


    local params=''
    if [ -n "${command}" ]; then
      params="${params} --command ${command}"
    fi


    # try fix setup script path from cellar if it not exist
    local setup_script_path="${script_path}"
    if [ -z "${setup_script_path}" ]; then
      setup_script_path=$(yxct_get_cellar_item "${command}" --setup-script)
    fi


    local result=
    if [ -n "${setup_script_path}" ]; then
      # 如果提供了脚本路径, 或从cellar找到了当时安装时的setup脚本

      if [ -n "${bin_path}" ]; then
        params="${params} --bin-path ${bin_path}"
      fi
      if ${all}; then
        params="${params} --all"
      fi


      uninstall_by_script_path --path "${setup_script_path}" ${params} --ignore ${ignore_reg_list[@]} ${additional}
      result=$?

    elif [ -n "${bin_path}" ]; then
      # 如果找不到脚本路径， 但bin_path不为空

      uninstall_by_bin_path --path "${bin_path}" ${params}
      result=$?
    elif [ -n "${command}" ]; then
      # 如果没提供脚本路径和bin_path, 但提供了command

      if ${all}; then
        params="${params} --all"
      fi

      local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
      if [ -n "${cellar_hash}" ]; then
        params="${params} --hash ${cellar_hash}"
      fi

      remove_command ${params}
      result=$?
    else
      yxct_fatal "Invalid parameters, use --help to show more information."
    fi
  fi


  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    if [[ "${result}" == 0 ]]; then
      yxct_msg "${command} uninstall success."
    else
      yxct_fatal "failed uninstall ${command}."
    fi
  fi

}

function cmd_update()
{
  local repo="${DIR}"
  local info_level=
  local no_depend=false
  local show_help=false

  while [ $# -gt 0 ]; do
    case $1 in
      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_update
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    # Force root
    if [ "$(id -u)" -ne 0 ]; then
      yxct_fatal "'${CMD} update' command should run with root"
    fi


    yxct_msg "begin update ${CMD}..."
    yxct_git_repo update --repo "${repo}" --branch 'main'
    local result=$?
    if [[ "${result}" == '0' ]]; then
      yxct_msg "done"
    elif [[ "${result}" == '11' ]]; then
      yxct_msg "${CMD} is already the latest version"
    else
      yxct_fatal "update failed"
    fi

    yxct_msg "begin update indexs library..."
    if ! update_index_if_need --force; then
      yxct_fatal "failed to update index library"
    fi

    yxct_msg "update success"

  fi

}

function cmd_upgrade()
{
  local script_path=
  local pass=
  local -a ignore_reg_list=
  local version=
  local additional=

  local use_cache=false
  local cache_path=

  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        script_path=$1
      ;;

      --cache )
        use_cache=true;
        if ! [[ "$2" =~ ^-.*$ ]]; then
          cache_path=$2
          shift
        fi
      ;;

      --pass )
        shift
        pass=$1
      ;;

      --version )
        shift
        version=$1
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --test )
        test=true;
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_uninstall
    exit 0
  elif [ -z "${command}" ]; then
    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    local params=
    if [ -n "${script_path}" ]; then
      params="${params} --path ${script_path}"
    fi

    if ${use_cache}; then
      if [ -n "${cache_path}" ]; then
        params="${params} --cache ${cache_path}"
      else
        params="${params} --cache"
      fi
    fi

    if ${pass}; then
      params="${params} --pass"
    fi

    if ${test}; then
      params="${params} --test"
    fi

    if ${no_depend}; then
      params="${params} --no-depend"
    fi

    if [ -n "${info_level}" ]; then
      params="${params} --info-level ${info_level}"
    fi

    if [ "${ignore_reg_list[0]}" ]; then
      params="${params} ${ignore_reg_list[@]}"
    fi


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    for installed_command in $(cmd_list | awk '{print $1}'); do
      yxct_msg "upgrade ${installed_command} ..."
      cmd_upgrade "${installed_command}" ${params} ${additional}
    done
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    yxct_msg "upgrade finished."


  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    
    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi



    #:! STEP 1.0
    # 确认版本号
    #
    # 1. 如果用户未提供版本号，但使用了--path参数，提供了 script_path, 
    #        则版本号使用CURRENT. CURRENT 用于尽量保证 script_path 指向的本地仓库内容不变
    #    如果用户未提供版本号，也未提供 --path参数
    #        则版本号使用LATEST, 尝试更新到最新版本
    #
    # 2. 比较用户要更新到的版本号和当前版本号，只有高于当前版本号，才能继续更新操作
    ######################################################################################
    if [ -z "${version}" ]; then
      if [ -n "${script_path}" ]; then
        version='CURRENT'
      else
        version='LATEST'
      fi
    fi
    # 如果version不是 latest 和 head, 则默认version为版本号。
    # 这里需要对比版本号
    if ! yxct_strcontains "${version}" "latest head current" --ignorecase; then

        # 如果本地不存在版本号，则不用验证
        local installed_version=$(yxct_get_cellar_item "${command}" --command-version)
        if [ -n "${installed_version}" ]; then
          yxct_strvercmp "${version}" "${installed_version}"
          local compare_result=$?
          if [[ "${compare_result}" == '0' ]]; then
            yxct_fatal "command ${command} ${version} is already installed."
          elif [[ "${compare_result}" == '2' ]]; then
            yxct_fatal "version '${version}' is less than current version:${installed_version}"
          fi
        fi

    fi


    #:! STEP 2.0
    # 获取安装路径
    # get bin-path
    ######################################################################################
    local bin_path=$(yxct_get_cellar_item "${command}" --bin-path)
    if [ -z "${bin_path}" ]; then
      yxct_fatal "failed to get dest paths"
    fi


    #:! STEP 3.0
    # 获取缓存路径
    # get a valid cache path
    # 如果 '--cache' 参数未提供 path, 则尝试从环境变量取cache路径。
    # 如果环境变量也没有，使用默认cache目录
    ######################################################################################
    if [ -z "${cache_path}" ]; then
      
      # 获取cache, cache 路径可以为空或不存在
      # 因为后面 如果未指定'--cache'参数，可以从网络拉取
      if [ -n "${YXCT_CACHE_PATH}" ]; then
        # 如果提供了环境变量， 从环境变量中读取 cache 路径
        cache_path="${YXCT_CACHE_PATH}"
      else
        # 如果没提供环境变量，使用默认cache路径
        cache_path="$(yxct_get_default_cache_path)"
      fi

    fi



    #:! STEP 4.0
    # 如果提供了 script_path, 且script 不在cache目录, 会将 script_path 拷贝到 cache 目录。 
    # 拷贝时，如果cache目录已经存在, 则覆盖之前的.
    ######################################################################################
    if [ -n "${script_path}" ]  &&  ! yxct_is_subpath "${cache_path}" "${script_path}"; then


      if [ -d "${script_path}" ]; then
      # 如果 script_path 是一个目录

        local install_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
        local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
        if [ -n "${install_script_filename}" ]  ||  [ -n "${singl_app_name}" ]; then
        # 如果找到安装脚本 或是单脚本命令, 需要将目录拷贝到cache 目录

          # 存在的话， 先删除
          local cmd_cache_path="${cache_path}/${command}"
          if [ -e "${cmd_cache_path}" ]; then
            yxct_verbcmd "${RM} -rf ${cmd_cache_path}"
          fi
          # 再创建
          yxct_verbcmd "${MKDIR} -p ${cmd_cache_path}"
          if ! [ -d "${cmd_cache_path}" ]; then
            yxct_fatal "failed to create dir:${cmd_cache_path}"
          fi
          # copy
          if ! yxct_verbcmd "${CP} -R ${script_path}/ ${cmd_cache_path}"; then
            yxct_fatal "failed to copy script dir to cache path"
          fi

          # 新的 script_path
          script_path="${cmd_cache_path}"

        else
          # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，还有多个文件，则不知道如何安装, 直接报错
          yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to install the command."
        fi

      elif [ -f "${script_path}" ]; then

        # 存在的话， 先删除
        local cmd_cache_path="${cache_path}/${command}"
        if [ -e "${cmd_cache_path}" ]; then
          yxct_verbcmd "${RM} -rf ${cmd_cache_path}"
        fi
        # 再创建
        yxct_verbcmd "${MKDIR} -p ${cmd_cache_path}"
        if ! [ -d "${cmd_cache_path}" ]; then
          yxct_fatal "failed to create dir:${cmd_cache_path}"
        fi
        # copy
        if ! yxct_verbcmd "${CP} ${script_path} ${cmd_cache_path}"; then
          yxct_fatal "failed to copy command to cache path"
        fi

        # 新的 script_path
        script_path="${cmd_cache_path}"

      else
        # 既不是文件，也不是目录，无效script_path
        yxct_fatal "Invalid script path:${script_path}"
      fi

    fi


    #:! STEP 5.0
    # 如果安装包是yxct格式，需要解压一次
    ######################################################################################
    local single_file_name=$(file_name_if_single "${script_path}")
    if [ -n "${single_file_name}" ]; then

      single_file_path="${script_path%\/}/${single_file_name}"
      if [ -n "${single_file_path}" ]; then

        # 这里通过扩展名，判断文件是否是一个 package
        local package_name=$(basename "${single_file_path}")
        if [[ "${package_name##*.}" == 'yxct' ]]; then

          local tmp_path=$(mktemp -d)
          if [ ! -d "${tmp_path}" ]; then
            yxct_fatal "Failed to create a temp directory"
          fi

          # 释放package里的内容
          local pass_params=
          if [ -n "${pass}" ]; then
            pass_params="--pass ${pass}"
          fi

          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
          if ! cmd_pack unpack --pack-path "${single_file_path}" --repo-path "${tmp_path}" --force ${pass_params}; then
            yxct_fatal "failed to unpack pakcage:${package}"
          fi
          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

          # 更新script_path路径
          script_path="${tmp_path%\/}/${package_name%.*}"
          # 更新cache_path路径
          cache_path="${tmp_path}"

        fi # end of (if [[ "${package_name##*.}" == 'yxct' ]]; then)

      fi # end of (if [ -n "${single_file_path}" ]; then)

    fi # end of (if [ -n "${single_file_name}" ]; then)


    #:! STEP 6.0
    # 更新indexs仓库(如果没有提供--cache参数， 不要求使用缓存, 才更新)
    ######################################################################################
    if ! ${use_cache}; then
      # update indexs library
      if ! update_index_if_need; then
        yxct_fatal "failed to update index"
      fi

    fi


    #:! STEP 7.0
    # 将 cache 切换到需要的版本。
    #     a.这里如果用户使用了--path参数(STEP 1.0), 且没指定--version. 则version 会被设置为CURRENT. 确保 cache 不被更新，保存本地更改
    #     b. 如果cache不存在，这里应该尝试下载新的仓库(待验证)
    ######################################################################################
    # 如果更新失败，会直接fatal.
    checkout_a_cache "${command}" --version "${version}" --cache-dir "${cache_path}"
    local checkout_result=$?
    if [[ "${checkout_result}" != '0' ]]; then
      if [[ "${checkout_result}" == '1' ]]; then
        # 正常情况, 仓库不在 indexs library 和 index.conf 控制下
        :
      elif [[ "${checkout_result}" == '2' ]]; then
        yxct_fatal "failed to update ${command}'s cache to version:${version}"
      elif [[ "${checkout_result}" == '3' ]]; then
        yxct_fatal "failed to checkout ${command}'s cache to version:${version}"
      elif [[ "${checkout_result}" == '4' ]]; then
        yxct_fatal "unknown version:${version} of command:${command}"
      fi
    fi


    #:! STEP 8.0
    # 前面的逻辑，会将安装包拷贝到cache目录。 然后让script_path指向这个路径。
    # 但如果用户没有传入--path参数，这里需要尝试在缓存中搜索命令
    # 缓存已经在 STEP 7.0 时，整备完成。
    ######################################################################################
    if [ -z "${script_path}" ]; then
      script_path=$(search_in_cache "${command}" "${cache_path}")
      if [ -z "${script_path}" ]; then
        yxct_fatal "can not find command ${command} from cache"
      fi
    fi



    #:! STEP 9.0
    # 开始更新逻辑
    ######################################################################################

    local params=''
    # --command
    if [ -n "${command}" ]; then
      params="${params} --command ${command}"
    fi
    
    # --bin-path
    if [ -n "${bin_path}" ]; then
      params="${params} --bin-path ${bin_path}"
    fi



    if [ -f "${script_path}" ]; then
    # 如果脚本路径是一个文件

      local script_file_name=$(basename ${script_path})
      if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
      # 如果文件是一个安装脚本, 直接调用脚本
        if run_setup_script upgrade --path "${script_path}" ${params} ${additional}; then
          
          local setup_cache_params=
          if [ -n "${cache_path}" ]; then
            setup_cache_params="--cache-dir ${cache_path}"
          fi

          setup_cellar upgrade "${command}" --install-script "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
        else
          yxct_fatal "failed on install ${command}"
        fi
      else
      # 如果文件是不是一个安装脚本


        if [[ "${script_file_name}" == "${command}" ]] ||  [[ "${script_file_name%.*}" == "${command}" ]]; then
        # 如果'--path'指向的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
          if install_file --file "${script_path}" --force ${params}; then
            
            local setup_cache_params=
            if [ -n "${cache_path}" ]; then
              setup_cache_params="--cache-dir ${cache_path}"
            fi
            
            setup_cellar upgrade "${command}" --install-file "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
          else
            yxct_fatal "failed on install ${command}"
          fi
        else
        # '--path'指向文件名与'command'不同的情况下，验证是否指定了 ‘--strict’ 参数. 没指定则强制安装文件, 并改名为command.
          if install_file --file "${script_path}" --force ${params}; then

            local setup_cache_params=
            if [ -n "${cache_path}" ]; then
              setup_cache_params="--cache-dir ${cache_path}"
            fi

            setup_cellar upgrade "${command}" --install-file "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
          else
            yxct_fatal "failed on install ${command}"
          fi
        fi

      fi
    elif [ -d "${script_path}" ]; then
      # 如果脚本路径是一个目录
      local install_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
      if [ -n "${install_script_filename}" ]; then
        # 如果目录中找到安装脚本, 直接掉用那个安装脚本
        local script_path="${script_path%\/}/${install_script_filename}"
        if run_setup_script upgrade --path "${script_path}" ${params} ${additional}; then
          
          local setup_cache_params=
          if [ -n "${cache_path}" ]; then
            setup_cache_params="--cache-dir ${cache_path}"
          fi

          setup_cellar upgrade "${command}" --install-script "${script_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
        else
          yxct_fatal "failed on install ${command}"
        fi
      else

        local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
        if [ -n "${singl_app_name}" ]; then
        # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，只剩下一个文件

          local app_path="${script_path%\/}/${singl_app_name}"
          if [[ "${singl_app_name}" == "${command}" ]] ||  [[ "${singl_app_name%.*}" == "${command}" ]]; then
          # 如果这唯一的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
            if install_file --file "${app_path}" --force ${params}; then

              local setup_cache_params=
              if [ -n "${cache_path}" ]; then
                setup_cache_params="--cache-dir ${cache_path}"
              fi

              setup_cellar upgrade "${command}" --install-file "${app_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
            else
              yxct_fatal "failed on install ${command}"
            fi
          else
          # 这唯一的文件与'command'名字不同的情况下，没指定则强制安装文件, 并改名为command.
            if install_file --file "${app_path}" --force ${params}; then

              local setup_cache_params=
              if [ -n "${cache_path}" ]; then
                setup_cache_params="--cache-dir ${cache_path}"
              fi

              setup_cellar upgrade "${command}" --install-file "${app_path}" --version "${version}" --bin-path "${bin_path}" ${setup_cache_params}
            else
              yxct_fatal "failed on install ${command}"
            fi
          fi
        else
          # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，还有多个文件，则不知道如何安装, 直接报错
          yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to install the command."
        fi

      fi
    else
    # 既不是文件，也不是目录，无效script_path
      yxct_fatal "Invalid script path:${script_path}"
    fi


  fi

  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    yxct_msg "${command} upgrade success."
  fi
}

function cmd_reinstall()
{
  local test=false
  local info_level=
  local additional=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi 


  while [ $# -gt 0 ]; do

    case $1 in

      --test )
        test=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_reinstall
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi

    local params=
    if ${test}; then
      params="${params} --test"
    fi

    if ${no_depend}; then
      params="${params} --no-depend"
    fi

    if [ -n "${info_level}" ]; then
      params="${params} --info-level ${info_level}"
    fi


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    if ! cmd_uninstall "${command}" ${params} ; then
      yxct_fatal "failed on remove old ${command}"
    fi
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    cmd_install "${command}" ${params} ${additional};
    local result=$?
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
      if [[ "${result}" == 0 ]]; then
        yxct_msg "${command} reinstall success."
      fi
    fi

  fi

}

#usage
# yxct_config set --key domain.name --val val
# usage
# yxct_config get --key domain.name
function cmd_config()
{
  local domain=
  local key=
  local val=
  local option=

  local info_level=
  local no_depend=false
  local show_help=false

  if ! [[ "$1" =~ ^-.*$ ]]; then
    if yxct_strcontains "$1" "get" --ignorecase; then
      option='GET'
    elif yxct_strcontains "$1" "set" --ignorecase; then
      option='SET'
    else
      option=$1
    fi

    shift
  else
    # get is default option
    option='GET'
  fi


  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
      --key )
        cursor=$1
      ;;

      --val )
        cursor=$1
      ;; 

      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--key' ]]; then
            key=$(echo "${key} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--val' ]]; then
            val=$(echo "${val} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yxct_fatal "invalid optional ${1}"
        fi
      ;;

    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_config
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    if [ -z "${key}" ]; then
      yxct_fatal "key is empty."
    fi


    # get domain section from key string.
    domain="${key%%\.*}"
    if [[ "${domain}" == "${key}" ]]; then
      yxct_fatal "invalid key format:${key}, no domain found"
    fi

    # get real key which remove 'domain' section from --key params
    key="${key#[^\.]*\.}"



    # get config directory
    local config_dir=$(yxct_get_cmd_item --config)
    if [ -z "${config_dir}" ]; then
      yxct_fatal "failed to get config dir"
    fi

    # read or write the config file
    local file="${config_dir}/${domain}"
    if [[ "${option}" == 'GET' ]]; then
      if [ -f "${file}" ]; then
        yxct_config_read --file "${file}" --key "${key}"
      fi
    elif [[ "${option}" == 'SET' ]]; then
      if ! [ -d "${config_dir}" ]; then
        yxct_verbcmd "${MKDIR} -p ${config_dir}"
        if ! [ -d "${config_dir}" ]; then
          yxct_verbcmd "failed to make dir:${config_dir}"
        fi
      fi

      yxct_config_write --file "${file}" --key "${key}" --val "${val}"
    fi


  fi # end of (if ${show_help}; then)

}

function cmd_pack()
{
  local repo_path=
  local pack_path=
  local pass=
  # local command=
  local encrypt=false
  local force=false

  local info_level=
  local no_depend=false
  local show_help=false
  local option=

  if ! [[ $1 =~ ^-.*$ ]]; then
    if yxct_strcontains "${1}" "pack" --ignorecase; then
      option='PACK'
    elif yxct_strcontains "${1}" "unpack" --ignorecase; then
      option='UNPACK'
    else
      option=$1
    fi
    shift
  fi

  # if ! [[ $1 =~ ^-.*$ ]]; then
  #   command=$1
  #   shift
  # fi

  local cursor=
  while [ $# -gt 0 ]; do

    case $1 in

      --repo-path )
        cursor=$1
      ;;

      --pack-path )
        cursor=$1
      ;;

      --pass )
        encrypt=true
        cursor=$1
      ;;

      --force )
        cursor=
        force=true
      ;;

      --info-level )
        shift
        cursor=
        info_level=$1
      ;;

      --no-depend )
        cursor=
        no_depend=true
      ;;

      --help | h )
        cursor=
        show_help=true
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--repo-path' ]]; then
            repo_path=$(echo "${repo_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--pack-path' ]]; then
            pack_path=$(echo "${pack_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--pass' ]]; then
            pass=$(echo "${pass} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "Invalid name of ${cursor} $1"
          fi
        else
          yxct_fatal "Invalid optional ${1}"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_pack
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    if [[ "${option}" == 'PACK' ]]; then
      

      if [ -z "${repo_path}" ]; then
        yxct_fatal "repo path is empty. Use '${CMD} pack --help' to show help information"
      fi

      if [ -z "${pack_path}" ]; then
        yxct_fatal "package path is empty"
      fi

      # Create a temp directory
      local tmp_path=$(mktemp -d)
      if [ ! -d "${tmp_path}" ]; then
        yxct_fatal "Failed to create a temp directory"
      fi

      local command=$(basename "${repo_path}")

      # Compress the package
      local tar_file="${tmp_path%\/}/tar"
      pushd $(dirname "${repo_path}") > /dev/null || yxct_fatal "failed to pushd ${repo_path}"
      yxct_verbcmd "${TAR} --create --file ${tar_file} ${command}"
      popd > /dev/null || yxct_fatal "failed to popd from ${repo_path}"


      # encrypt if need
      local target_file=
      local pack_file=
      if ${encrypt}; then

        local encrypt_file="${tmp_path%\/}/encrypted"
        if [ -z "${pass}" ]; then
          if [ -z "${pkg_pass}" ]; then
            local pass1=
            local pass2=
            echo -n "Enter encryption password:"
            read -s pass1
            echo ""

            echo -n "Verifying encryption password:"
            read -s pass2
            echo ""

            if [[ "${pass1}" == "${pass2}" ]]; then
              pass="${pass1}"
            else
              yxct_fatal "Password not matched"
            fi
          fi
        fi

        if ! yxct_verbcmd "${OPENSSL} enc -e -aes256 -iter 100 -pbkdf2 -in ${tar_file} -out ${encrypt_file} --pass pass:${pass}"; then
          yxct_fatal "Failed to encrypt package"
        fi

        target_file="${encrypt_file}"
        # pack_file="${pack_path}/${command}.yxct"
      
      else
        target_file="${tar_file}"
        # pack_file="${pack_path}/${command}.yxct"
      fi

      # Make pack file's dir if not exist
      if ! [ -d "${pack_path}" ]; then
        yxct_err "${pack_path} not exist, try create one"
        yxct_verbcmd "${MKDIR} -p ${pack_path}" > /dev/null
        if ! [ -d "${pack_path}" ]; then
          yxct_fatal "failed to mkdir ${pack_path}"
        fi
      fi

      # copy file
      local force_params=''
      local pack_file="${pack_path}/${command}.yxct"
      if [ -f "${pack_file}" ]; then
        if "${force}"; then
          force_params="-f"
        else
          yxct_fatal "file ${pack_file} already exist, use '--force' to replace it or '${CMD} pack --help' to show help information"
        fi
      fi

      if ! yxct_verbcmd "${CP} ${force_params} ${target_file} ${pack_file}"; then
        yxct_fatal "failed to copy file to ${pack_file}"
      else
        if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
          yxct_msg "pack success"
        fi
      fi

     
    elif [[ "${option}" == 'UNPACK' ]]; then
      if [ -z "${repo_path}" ]; then
        yxct_fatal "repo path is empty. Use '${CMD} pack --help' to show help information"
      fi

      if [ -z "${pack_path}" ]; then
        yxct_fatal "package path is empty"
      elif ! [ -f "${pack_path}" ]; then
        yxct_fatal "package path ${pack_path} not exist"
      fi


      # Create a temp directory
      local tmp_path=$(mktemp -d)
      if [ ! -d "${tmp_path}" ]; then
        yxct_fatal "Failed to create a temp directory"
      fi




      # decrypt if need
      # target_path & repo_path
      local target_path=
      local filename=$(basename "${pack_path}")
      if ! "${TAR}" -tf "${pack_path}" &> /dev/null; then
        local decrpyt_file="${tmp_path%\/}/decrypt"

        local pass_param=''
        if [ -n "${pass}" ]; then
          pass_param="--pass pass:${pass}"
        fi
        if ! "${OPENSSL}" enc -d -aes256 -iter 100 -pbkdf2 -in "${pack_path}" --out "${decrpyt_file}" ${pass_param}; then
          yxct_fatal "failed to dencrypt file:${pack_path}"
        fi

        target_path="${decrpyt_file}"
      else
        target_path="${pack_path}"
      fi


      # extract package
      local extra_path="${tmp_path%\/}/extra"
      if ! "${MKDIR}" -p "${extra_path}"; then
        yxct_fatal "failed to make dir:${target_path}"
      fi
      if ! yxct_verbcmd "/usr/bin/tar --extract --file=${target_path} --directory=${extra_path}"; then
        yxct_fatal "failed to extract package"
      fi
      target_path="${extra_path}"


      # search extract result
      # must only one file or directory in package.
      local repo_name=
      local finded=false
      for file in "${target_path%\/}"/*; do
        if ${finded}; then
          yxct_fatal "mutiple files or directory in package"
        fi

        finded=true
        repo_name=$(basename "${file}")
      done

      if [ -z "${repo_name}" ]; then
        yxct_fatal "failed to find file or directory in package"
      fi

      target_path="${target_path%\/}"/${repo_name}



      # Make repo file's dir if not exist
      if ! [ -d "${repo_path}" ]; then
        yxct_err "${repo_path} not exist, try create one"
        yxct_verbcmd "${MKDIR} -p ${repo_path}" > /dev/null
        if ! [ -d "${repo_path}" ]; then
          echo_fatal "failed to mkdir ${repo_path}"
        fi
      fi

      # copy file
      local params=''
      if [ -f "${repo_path}" ]; then
        if "${force}"; then
          params="-f"
        else
          yxct_fatal "file ${repo_path} already exist, use '--force' to replace it or '${CMD} unpack --help' to show help information"
        fi
      fi

      if [ -d "${target_path}" ]; then
        params="${params} -R"
      fi

      if ! yxct_verbcmd "${CP} ${params} ${target_path} ${repo_path}"; then
        yxct_fatal "failed to copy file to ${pack_file}"
      else
        if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
          yxct_msg "unpack success"
        fi
      fi


    fi # end of(if [[ "${option}" == 'PACK' ]]; then)


  fi # end of (if ${show_help}; then)
}

function cmd_search()
{
  local use_cache=false
  local cache_path=

  local info_level=
  local no_depend=false
  local show_help=false

  local use_reg=false
  local search_string=
  if [[ -n $1 ]] && ! [[ $1 =~ ^-.*$ ]]; then
    search_string=$1
    shift
  else
    yxct_fatal "search string is empty."
  fi

  local cursor=
  while [ $# -gt 0 ]; do

    case $1 in

      --cache )
        cursor=$1
        use_cache=true
        cache_path=
      ;;

      --reg )
        cursor=
        use_reg=true
      ;;

      --info-level )
        cursor=
        shift
        info_level=$1
      ;;

      --no-depend )
        cursor=
        no_depend=true
      ;;

      --help | h )
        cursor=
        show_help=true
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--cache' ]]; then
            cache_path=$(echo "${cache_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yxct_fatal "invalid optional ${1}"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_search
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if ! update_index_if_need; then
      yxct_fatal "failed to update index"
    fi


    # 如果不使用正则搜索, 要跑一边 escape
    if ! ${use_reg}; then
      search_string=$(echo "${search_string}" | _yxct_grep_escape) # 如果不使用正则，放开这行
    fi


    if ${use_cache}; then
      
      # get a valid cache path
      # 如果 '--cache' 参数未提供 path
      if [ -z "${cache_path}" ]; then
        
        # 获取cache, cache 路径可以为空或不存在
        # 因为后面 如果未指定'--cache'参数，可以从网络拉取
        if [ -n "${YXCT_CACHE_PATH}" ]; then
          # 如果提供了环境变量， 从环境变量中读取 cache 路径
          cache_path="${YXCT_CACHE_PATH}"
        else
          # 如果没提供环境变量，使用默认cache路径
          cache_path="$(yxct_get_default_cache_path)"
        fi
      fi

      for item in "${cache_path%\/}"/*; do
        local filename=$(basename "${item}")
        if [[ "${filename}" == '*' ]]; then
          continue
        fi

        # check the search string
        if ! echo "${filename%.*}" | grep -Eiq "${search_string}"; then
          continue
        fi

        # 再用search_in_cache验证一下
        local cache_result=$(search_in_cache "${filename%.*}" "${cache_path}")
        if [ -n "${cache_result}" ]; then
          echo "${filename%.*}"
        fi

      done
    
    else

      if ! update_index_if_need; then
        yxct_fatal "failed to update index"
      fi

      local index_repo=$(yxct_get_cmd_item --index-repo)
      if [ -z "${index_repo}" ]; then
        yxct_fatal "failed to get index repo path"
      fi

      for config in "${index_repo%\/}"/index/*.conf; do

        local filename=$(basename "${config}")
        if [[ "${filename}" == '*.conf' ]]; then
          continue
        fi

        # check the search string
        if ! echo "${filename%.*}" | grep -Eiq "${search_string}"; then
          continue
        fi

        #output
        echo "${filename%.*}"

      done

    fi

  fi
}


function cmd_info()
{
  local info_level=
  local no_depend=false
  local show_help=false

  local install_info=false
  local indexs_info=false
  local cache_info=false
  local cache_path=

  local command=
  if [ -n "$1" ] && ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  fi


  while [ $# -gt 0 ]; do

    case $1 in

      --cache )
        cache_info=true;
        if ! [[ "$2" =~ ^-.*$ ]]; then
          cache_path=$2
          shift
        fi
      ;;

      --installed )
        install_info=true
      ;;

      --indexs )
        indexs_info=true
      ;;

      --all )
        install_info=true;
        indexs_info=true
        cache_info=true;
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        yxct_fatal "invalid optional ${1}"
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_info
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "command is empty. use '--help' to see more information"
    fi

    # 因为info命令要输出信息, 这里静默更新
    # 静默更新，只作用于标准输出和错误输出。 文件日志和syslog 扔会有输出
    if ! update_index_if_need &> /dev/null; then
      yxct_fatal "failed to update index"
    fi

    #-------------------------------------------------------------------------------
    ################################################################################
    # cellar, 判断是否已安装
    ################################################################################
    local cmd_cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)

    ################################################################################
    # cache content, 判断缓存是否存在
    ################################################################################
    # 如果 '--cache' 参数未提供 path
    if [ -z "${cache_path}" ]; then
      
      # 获取cache, cache 路径可以为空或不存在
      # 因为后面 如果未指定'--cache'参数，可以从网络拉取
      if [ -n "${YXCT_CACHE_PATH}" ]; then
        # 如果提供了环境变量， 从环境变量中读取 cache 路径
        cache_path="${YXCT_CACHE_PATH}"
      else
        # 如果没提供环境变量，使用默认cache路径
        cache_path="$(yxct_get_default_cache_path)"
      fi
    fi
    local search_result_in_cache=$(search_in_cache "${command}" "${cache_path}")

    ################################################################################
    #indexs git addr, 判断indexs是否存在
    ################################################################################
    local gitaddr=$(search_in_index "${command}" --key 'repo')
    #-------------------------------------------------------------------------------


    # 如果未指定参数显示哪种信息， 按照优先级顺序，显示一个 
    # 已安装信息 > indexs 信息 > 缓存信息
    if ! ${install_info}  &&  ! ${cache_info}  &&  ! ${indexs_info}; then
      if [ -n "${cmd_cellar_path}" ] && [ -d "${cmd_cellar_path}" ]; then
        install_info=true
      elif [ -n "${gitaddr}" ]; then
        indexs_info=true
      elif [ -n "${search_result_in_cache}" ]; then
        cache_info=true
      fi
    fi

    
    # installed info
    if ${install_info}; then
      printf "[install info]:\n"

      if [ -n "${cmd_cellar_path}" ] && [ -d "${cmd_cellar_path}" ]; then
        printf "installed:YES\n"

        local version=$(yxct_get_cellar_item "${command}" --command-version)
        if [ -n "${version}" ]; then
          printf "version:${version}\n"
        fi

        local dest=$(yxct_get_cellar_item "${command}" --bin-path)
        if [ -n "${dest}" ]; then
          printf "dest:${dest}\n"
        fi

        local setup_script=$(yxct_get_cellar_item "${command}" --setup-script)
        if [ -n "${setup_script}" ]; then
          printf "setup script:YES\n"
        else
          printf "setup script:NO\n"
        fi

        local git_addr=$(yxct_get_cellar_item "${command}" --command-gitaddr)
        if [ -n "${git_addr}" ]; then
          printf "git address:${git_addr}\n"
        fi

        local git_hash=$(yxct_get_cellar_item "${command}" --command-githash)
        if [ -n "${git_hash}" ]; then
          printf "git hash:${git_hash}\n"
        fi

        local command_hash=$(yxct_get_cellar_item "${command}" --command-hash)
        if [ -n "${command_hash}" ]; then
          printf "file hash:${command_hash}\n"
        fi
      else
        printf "installed:NO\n"
      fi

      printf "\n"
    fi



    # cached info
    if ${cache_info}; then
      printf "[cache info]:\n"


      if [ -n "${search_result_in_cache}" ]; then

        printf "exist:YES\n"

        if [ -f "${search_result_in_cache}" ]; then

          printf "git:NO\n"

          local filename=$(basename "${search_result_in_cache}")
          if [[ "${filename##*.}" == "yxct" ]]; then
            # 缓存类型时一个 yxct package
            printf "type:${CMD} package\n"
            printf "setup-script:UNKNOWN\n"
          elif echo "${filename}" |  grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
            # 缓存类型时一个 安装脚本
            printf "type:setup-script\n"
            printf "setup-script:YES\n"
          else
            # 缓存类型时一个 文件 
            printf "type:file\n"
            printf "setup-script:NO\n"
          fi

        elif [ -d "${search_result_in_cache}" ]; then

          if yxct_git_repo info --repo "${search_result_in_cache}"; then
            printf "git:YES\n"
          else
            printf "git:NO\n"
          fi

          local install_script_filename=$(search_file_by_reg_list "${search_result_in_cache}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
          if [ -n "${install_script_filename}" ]; then
            # 缓存类型时一个 携带安装脚本的目录
            printf "type:dir\n"
            printf "setup-script:YES\n"
          else
            # 缓存类型时一个目录，但目录中只有一个文件
            local singl_app_name=$(file_name_if_single "${search_result_in_cache}")
            if [ -n "${singl_app_name}" ]; then
              printf "type:file\n"
              printf "setup-script:NO\n"
            else
              # 为之类型，基本时坏掉的缓存，不能使用
              printf "type:unknown\n"
              printf "setup-script:NO\n"
            fi
          fi
        fi
      else
        printf "exist:NO\n"
      fi

      printf "\n"
    fi


    if ${indexs_info}; then
      printf "[indexs info]:\n"

      # 这里用 git addr 判断 index 是否存在
      if [ -n "${gitaddr}" ]; then
        printf "exist:YES\n"
        printf "address:${gitaddr}\n"


        # latest version
        local latest=$(search_in_index "${command}" --key 'latest')
        if [ -n "${latest}" ]; then
          printf "latest:${latest}\n"
        fi

        printf "top 10 available version:\n"
        local count=0
        local column=0
        for version in $(search_in_index yxfirewall --all-version); do

          local prefix=''

          ((column=column+1))
          ((count=count+1))

          if ! [ "${column}" -eq '1' ]; then
            prefix=', '
          fi

          printf "%s%s" "${prefix}" "${version}"

          if [ "${column}" -eq '5' ]; then
            printf "\n"
            column=0
          fi

          if [ "${count}" -eq '10' ]; then
            break
          fi

        done
        
        if ! [ "${column}" -eq '0' ]; then
          printf "\n"
        fi

      else
        printf "exist:NO\n"
      fi

      # printf "\n"
    fi

  fi
}

function cmd_list()
{
  local info_level=
  local no_depend=false
  local show_help=false

  while [ $# -gt 0 ]; do

    case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_list
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    local cmd_cellar_path=$(yxct_get_cellar_item "${CMD}" --cellar-path)
    if [ -z "${cmd_cellar_path}" ]; then
      yxct_fatal "failed to get command cellar path"
    fi

    local cellar_path=$(dirname "${cmd_cellar_path}")
    if [ -z "${cellar_path}" ]; then
      yxct_fatal "failed to get cellar path"
    fi

    for item in "${cellar_path%\/}"/*; do

      local command=$(basename "${item}")
      if [[ "${command}" == '*' ]]; then
        continue
      fi

      local version=$(yxct_get_cellar_item "${command}" --command-version)


      printf "%s\t%s\n" "${command}" "${version}"

    done

  fi

}


####################################################################################################
# Entry
####################################################################################################


# 不要限制'PATH', 会引起`which`命令无法查找
# PATH=/sbin:/bin:/usr/bin

# 设置默认日志级别。
if [ -n "${YXLOGGER_DEFAULT_LEVEL}" ]; then
  # 尝试继承当前环境中YXLib的日志级别。
  yxct_set_info_level "${YXLOGGER_DEFAULT_LEVEL}"
else
  # 使用 yxct 级别 设置日志级别
  # 注意: 这里扔需要设置一次
  # 因为 yxct_set_inf_level 可能需要将默认参数透传给 YXLogger
  yxct_set_info_level "${YXCT_DEFAULT_LEVEL}"
fi

# 如果syslog的tag没被设置(没有上层脚本), 则将其设置为${CMD}
if [ -n "${YXLOGGER_SYSLOG_TAG}" ]; then
  YXLOGGER_SYSLOG_TAG="${CMD}"
fi

if [[ $(yxct_os_type) == 'osx' ]]; then
  # on osx, '/usr/local/sbin' is not a standard bin path
  BIN_PATH="${USR_LOCAL_BIN_PATH}"
  SBIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_BIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_SBIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_LOCAL_SBIN_PATH="${USR_LOCAL_BIN_PATH}"

  CP=/bin/cp
  RM=/bin/rm
  CHMOD=/bin/chmod
  BASH=/bin/bash
  ENV=/usr/bin/env
  MKDIR=/bin/mkdir
  LN=/bin/ln
  TAR=/usr/bin/tar
  OPENSSL=/usr/local/bin/openssl
else
  CP=/usr/bin/cp
  RM=/usr/bin/rm
  CHMOD=/usr/bin/chmod
  BASH=/bin/bash
  ENV=/usr/bin/env
  MKDIR=/usr/bin/mkdir
  LN=/usr/bin/ln
  TAR=/usr/bin/tar
  OPENSSL=/usr/bin/openssl
fi



sub_cmd=$1
shift
if [[ -z ${sub_cmd} ]]; then
  yxct_fatal "Param error. use '${CMD} --help' to show document"
fi

# 用于命令嵌套调用识别
if [ -z "${YXCT_NESTED_FLAG}" ]; then
  export YXCT_NESTED_FLAG=1
else
  YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
fi

# 用于子命令再次调用 YXCT, 而系统中安装多个版本YXCT时，出现混乱
if [ -z "${YXCT}" ]; then
  export YXCT="${SOURCE}"
fi


if [[ "${sub_cmd}" == 'install' ]]; then
  cmd_install $@;
elif [[ "${sub_cmd}" == 'uninstall' ]]; then
  cmd_uninstall $@
elif [[ "${sub_cmd}" == 'reinstall' ]]; then
  cmd_reinstall $@
elif [[ "${sub_cmd}" == 'update' ]]; then
  cmd_update $@
elif [[ "${sub_cmd}" == 'upgrade' ]]; then
  cmd_upgrade $@
elif [[ "${sub_cmd}" == 'search' ]]; then
  cmd_search $@
elif [[ "${sub_cmd}" == 'info' ]]; then
  cmd_info $@
elif [[ "${sub_cmd}" == 'list' ]]; then
  cmd_list $@
elif [[ "${sub_cmd}" == 'pack' ]]; then
  cmd_pack pack $@
elif [[ "${sub_cmd}" == 'unpack' ]]; then
  cmd_pack unpack $@
elif [[ "${sub_cmd}" == 'set' ]]; then
  cmd_config set $@
elif [[ "${sub_cmd}" == 'get' ]]; then
  cmd_config get $@
elif [[ "${sub_cmd}" == '-' ]]; then
  : # nested call. do nothing ...
elif [[ "${sub_cmd}" == '--help' ]] || [[ "${sub_cmd}" == '-h' ]]; then
  yxct_usage
else
  yxct_fatal "Unknown sub command:'${sub_cmd}'. Use ${CMD} --help tho show help information."
fi


YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))