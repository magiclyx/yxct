#!/usr/bin/env bash

if [ -z "${CMD}" ]; then
  CMD=$(basename $0)
fi


if [ -z "${SOURCE}" ]; then
  SOURCE="$0"
  DIR=
  while [ -h "$SOURCE"  ]; do
    DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd  )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /*  ]] && SOURCE="$DIR/$SOURCE"
  done
  DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd  )"
fi


if [ -z "${YXCT_USEYXLIB}" ]; then
  if which yxlibinit > /dev/null; then
    source yxlibinit -
    source yxlogger
    export YXCT_USEYXLIB=true
  else
    export YXCT_USEYXLIB=false
  fi
elif "${YXCT_USEYXLIB}"; then
  source yxlogger
fi



BIN_PATH='/bin'
SBIN_PATH='/sbin'
USR_BIN_PATH='/usr/bin'
USR_SBIN_PATH='/usr/sbin'
USR_LOCAL_BIN_PATH='/usr/local/bin'
USR_LOCAL_SBIN_PATH='/usr/local/sbin'
DEFAULT_BIN_PATH="${USR_LOCAL_BIN_PATH}"


# index about
YXCT_INDEX_DEFAULT_GIT_ADDR='git@github.com:magiclyx/yxctindex.git'
YXCT_INDEX_DEFAULT_GIT_BRANCH='master'
YXCT_INDEX_DEFAULT_SCHEDULE=7day


#Display comand only, not run
if [ -z "${TEST_ONLY}" ]; then
  TEST_ONLY=false
fi

##############################################################
# !! 因为yxct不能用YXLib, 下面这些变量必须与yxlogger 中定义的相同
##############################################################
readonly YXCT_LEVEL_SILENT=0
readonly YXCT_LEVEL_FATAL=1
readonly YXCT_LEVEL_ERROR=4
readonly YXCT_LEVEL_WARN=5
readonly YXCT_LEVEL_INFO=8
readonly YXCT_LEVEL_VERBOSE=9
readonly YXCT_LEVEL_DEBUG=11
readonly YXCT_LEVEL_TRACE=12
readonly YXCT_LEVEL_ALL=99

if [ -z "${YXCT_DEFAULT_LEVEL}" ]; then
  YXCT_DEFAULT_LEVEL="${YXCT_LEVEL_INFO}"
fi


###########################################################
# Ignore file list in script folder
###########################################################

IGNORE_LIST=(
  # git
  "\.gitignore"
  "\.git"
  "\.gitkeep"
  
  ################
  #vim
  # # vim->swap
  "[._]*\.s[a-v][a-z]"
  "[._]*.sw[a-p]"
  "[._]s[a-rt-v][a-z]"
  "[._]ss[a-gi-z]"
  "[._]sw[a-p]"
  # # vim->session
  "Session"
  "Sessionx"
  # # vim->Temporary
  "\.netrwhist"
  "\*~"
  # # vim->Auto-generated tag files
  "tags"
  # # vim->Persistent undo
  "[._]*.un~"
  
  ################
  #vscode
  "\.vscode"
  # # vscode->Local History for Visual Studio Code
  "\.history"
  # # vscode->Built Visual Studio Code Extensions
  ".*\.vsix"
  # # vscode->VisualStudioCode Patch
  "\.history"
  "\.ionide"
  
  # custom
  "README(\.md)?"
  "test(\.sh)?"
  "sample(\.sh)?"
)


###########################################################
# YXLib
###########################################################
# 第一个参数，必须是script path.
function yxct_run_script()
{
  # get script file path from command
  local script_path=$(echo $@ | awk '{print $1}')
  
  if [ -n "${script_path}" ]; then
    
    # get shebang line from command
    local shebang=$(head -n 1 "${script_path}")
    if echo ${shebang} | grep -Eq "^#!.*"; then
      # if shebang exist, call commmand directly
      yxct_verbcmd "eval $@"
    else
      # try get file extension name
      local file_ext=${script_path##*.}

      # call command by extension name
      if [ -n "${file_ext}" ]; then
        if yxct_strcontains "${file_ext}" "sh" --ignorecase; then
          yxct_verbcmd "eval ${BASH} $@"
        elif yxct_strcontains "${file_ext}" "py" --ignorecase; then
          yxct_verbcmd "eval ${ENV} python3 $@"
        else
          yxct_verbcmd "eval $@"
        fi
      fi

    fi # end of (echo ${title} | grep -Eq "^#!.*"; then)
  fi # end of (if [ -n "${script_path}" ]; then)
}


function yxct_os_type()
{
  
  local release=''
  
  if [ -n "${OSTYPE}" ]; then
    if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
      release="linux"
    elif [[ "${OSTYPE}" == "bsd"* ]]; then 
      release="bsd"
    elif [[ "${OSTYPE}" == "freebsd"* ]]; then 
      release="freebsd"
    elif [[ "${OSTYPE}" == "darwin"* ]]; then 
      release="osx"
    elif [[ "${OSTYPE}" == "solaris"* ]]; then 
      release="solaris"
    elif [[ "${OSTYPE}" == "cygwin" ]]; then 
      # POSIX compatibility layer and Linux environment emulation for Windows 
      release="cygwin"
    elif [[ "${OSTYPE}" == "msys" ]]; then 
      # Lightweight shell and GNU utilities compiled for Windows (part of MinGW) 
      release="msys"
    elif [[ "${OSTYPE}" == "win32" ]]; then 
      # I'm not sure this can happen. 
      release="windows"
    else 
      release="unknown"
    fi
  else
    
    # $OSTAYPE not recognized by the older shells (such as Bourne shell).
    # Use `uname` instead
    
    case $(uname | tr '[:upper:]' '[:lower:]') in
      linux*)
        release='linux'
      ;;
      freebsd*)
        release='freebsd'
      ;;
      darwin*)
        release="osx"
      ;;
      SunOS*)
        release="solaris"
      ;;
      msys*)
        release="msys"
      ;;
      windows*)
        release="windows"
      ;;
      *)
        release="unknown"
      ;;
    esac
  fi
  

  echo "${release}"
}

function yxct_verbose()
{
  if ${YXCT_USEYXLIB}; then
    yx_verb $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_VERBOSE}" )); then
      return
    fi

    (>&1 echo "$1")

  fi


}

function yxct_msg()
{
  if ${YXCT_USEYXLIB}; then
    yx_msg $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_INFO}" )); then
      return
    fi

    echo $*

  fi


}

function yxct_fatal()
{
  YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

  if ${YXCT_USEYXLIB}; then
    yx_fatal $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" >= "${YXCT_LEVEL_FATAL}" )); then
      local red=$(tput setaf 1);
      local reset=$(tput sgr0);
      
      (>&2 echo "${red}Fatal:${1}${reset}");
    fi

    exit 1;

  fi


}


function yxct_verbcmd()
{
  if ${YXCT_USEYXLIB}; then
    if ${TEST_ONLY}; then
      yx_verbcmd --test $@
    else
      yx_verbcmd $@
    fi
  else
    if ${TEST_ONLY}; then
      yxct_verbose "Test-only:$*"
      return
    else
      yxct_verbose "$*"
    fi

    $@
  fi


}

function yxct_err()
{
  if ${YXCT_USEYXLIB}; then
    yx_err $@
  else
    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_ERROR}" )); then
      return
    fi

    local magenta=$(tput setaf 5);
    local reset=$(tput sgr0);

    (>&2 echo "${magenta}${1}${reset}")
  fi

}

function yxct_str_checkfmt()
{
  local reg=$1
  local str=$2
  
  if [[ -z ${str} ]]; then
    str=''
  fi
  
  if [[ -z ${reg} ]]; then
    reg='^\s*[^\s]+\s*$'
  fi
  
  if ! [[ ${str} =~ ${reg} ]] ; then
    return 1
  fi
  
  return 0
}

function yxct_strcontains()
{
  local str="$1"
  local arr_str="$2"
  local ignorecase=false
  shift 
  shift 
  
  while [ $# -gt 0 ]; do
    case $1 in
      
      --ignorecase )
        ignorecase=true
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done

  
  if ${ignorecase}; then
    if [[ $(yxct_shell_type) == 'bash' ]]; then
      for e in $(echo "${arr_str}"); do
        [[ "${e^^}" == "${str^^}" ]] && return 0
      done
    else
      for e in $(echo "${arr_str}"); do
        [[ "${e:u}" == "${str:u}" ]] && return 0
      done
    fi
  else
    for e in $(echo "${arr_str}"); do
      echo "compare between ${e} and ${str}"
      [[ "${e}" == "${str}" ]] && return 0
    done
  fi
  
  return 1
}

function yxct_shell_type()
{
  local shell_type=
  if [ -n "${ZSH_VERSION}" ]; then
    shell_type='zsh'
  elif [ -n "${BASH_VERSION}" ]; then
    shell_type='bash'
  else
    :
  fi

  echo "${shell_type}"
}

function yxct_datastr_to_second()
{
	local -A REG_MAP
	REG_MAP=(
		[YEAR]='(y|year|years)'
		[MONTH]='(mon|month|months)'
		[DAY]='(d|day|days)'
		[HOUR]='(h|hour|hours)'
		[MINUTE]='(m|min|minute|minutes)'
		[SECOND]='(s|sec|second|seconds)'
	)
	
	local -A SECOND_MAP
	SECOND_MAP=(
		[YEAR]='31104000'
		[MONTH]='2592000'
		[DAY]='86400'
		[HOUR]='3600'
		[MINUTE]='60'
		[SECOND]='1'
	)
	
	
	local result=0
	local date_str=$(echo "${1}" | tr '[:upper:]' '[:lower:]' | grep -o "[^ ]\+\( \+[^ ]\+\)*")
	for tag in YEAR MONTH DAY HOUR MINUTE SECOND; do	
		local section=$(echo "${date_str}" | grep -oE "^\s*\d+${REG_MAP[${tag}]}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
		
		if [ -n "${section}" ]; then
			
			local num=$(echo "${section}" | grep -oE "^\d+" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
			if [ -z "${num}" ]; then
				yxct_fatal "invalid time format:$1"
			fi
			

			((result=result+SECOND_MAP["${tag}"]*num))
			
			
			local fix_section=$(echo "${section}" | _yxct_sed_escape)
			date_str=$(echo "${date_str}" | sed -e "s/^${fix_section}//g")
		fi
		
	done
	
	if ! [ -z "${date_str}" ]; then
		yxct_fatal "invalid time format:$1"
  else
    echo "${result}"
	fi
	
}


###########################################################
# config
###########################################################

function _yxct_sed_escape() {
  sed -e 's/[][\/^$?*.]/\\&/g'
}

function _yxct_grep_escape() {
  sed -e 's/[][\/^$?+*.]/\\&/g' 
}

function yxct_config_read()
{

  local file=
  local key=

  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
    --file )
      cursor=$1
      shift
      file=$1
    ;;

    --key )
      cursor=$1
      shift
      key=$1
    ;;

    *)
      if [[ "${cursor}" == '--file' ]]; then
        file="${file} $1"
      elif [[ "${cursor}" == '--key' ]]; then
        key="${key} $1" 
      else
        yxct_fatal "Invalid optional ${1}"
      fi
    ;;
    esac
    shift
  done

  if [ -z "${key}" ]; then
    yxct_fatal 'key is empty'
  fi

  if [ -z "${file}" ]; then
    yxct_fatal 'file is empty'
  fi


  local sed_fixkey=$(echo "${key}" | _yxct_sed_escape)
  local grep_fixkey=$(echo "${key}" | _yxct_grep_escape)
  test -f "${file}" && grep -E "^\s*${grep_fixkey}\s*=\s*" "${file}" | sed -e  "s/[[:space:]]*${sed_fixkey}[[:space:]]*=[[:space:]]*//g" | grep -o "[^ ]\+\( \+[^ ]\+\)*"
}


function yxct_config_write()
{

  local file=
  local key=
  local val=
  local space=' '
  local nospace=false
  local duplicate=false

  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
    --file )
      cursor=$1
      shift
      file=$1
    ;;

    --key )
      cursor=$1
      shift
      key=$1
    ;;

    --val )  
      cursor=$1
      shift
      val=$1
    ;;

    --no-space )
      # A = B 还是 A=B
      # 如果部分配置文件，不允许等号两旁优空格
      # 使用 --no-space
      cursor=
      nospace=true
    ;;

    --duplicate-key )
      # Key 是否可以重复。
      # 如果当存在 A = 2 时， 写入 A = 3
      # 默认行为是将 A = 2 替换为 A = 3
      # 当使用 --dupliate-key 参数时 
      # 会在 A = 2 下面 添加 A = 3.
      cursor=
      duplicate=true
    ;;


    *)
    if [[ "${cursor}" == '--file' ]]; then
        file="${file} $1"
      elif [[ "${cursor}" == '--key' ]]; then
        key="${key} $1" 
    elif [[ "${cursor}" == '--val' ]]; then
        val="${val} $1" 
      else
        yxct_fatal "Invalid optional ${1}"
      fi
    ;;
    esac
    shift
  done


  if [ -z "${key}" ]; then
    yxct_fatal 'key is empty'
  fi

  if [ -z "${val}" ]; then
    yxct_fatal 'val is empty'
  fi

  if [ -z "${file}" ]; then
    yxct_fatal 'file is empty'
  fi

  # 部分配置文件，不允许等号两旁有空格
  if ${nospace}; then
    space=''
  fi


  local sed_fixkey=$(echo "${key}" | _yxct_sed_escape)
  local grep_fixkey=$(echo "${key}" | _yxct_grep_escape)

  local sed_fixval=$(echo "${val}" | _yxct_sed_escape)
  local grep_fixval=$(echo "${val}" | _yxct_grep_escape)

  if test -f "${file}" &&  grep -Eq "^\s*${grep_fixkey}\s*=\s*${grep_fixval}\s*$" "${file}"; then # Testfile exist and text 'key = val' exist, do nothing ...
    :
  elif test -f "${file}" && grep -Eq "^\s*${grep_fixkey}\s*=.*$" "${file}"; then #Test file exist and text 'key = xxx' exist
    if ${duplicate}; then
      if [[ $(yxct_os_type) == 'osx' ]]; then
        # 因为sed在OSX上的问题，这里不得不换行!!!
        sed -i "" "/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
        ${sed_fixkey} = ${sed_fixval}\\
        " "${file}"
      else
        sed -i "/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${sed_fixval}" "${file}"
      fi
    else
      if [[ $(yxct_os_type) == 'osx' ]]; then
        sed -i "" "s/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      else
        sed -i "s/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      fi
    fi
  elif test -f "${file}" && grep -Eq "^\s*#\s*${grep_fixkey}\s*=.*$" "${file}"; then #Test file exist and text '# key = xxx' exist
    if   grep -Eq "^\s*#\s*${grep_fixkey}\s*=\s*${grep_fixval}\s*$" "${file}"; then #Test exist '# key = val', remove '#' and format line.
      if [[ $(yxct_os_type) == 'osx' ]]; then
        sed -i "" "s/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      else
        sed -i "s/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${sed_fixval}/g" "${file}"
      fi
    else # Text '# key=???' exist, append 'key = val' below.
        ##############################################################################################
      # 这里有个Bug, 当sed 使用 'a' 追加模式时， 如果同时使用了 "复杂的正则表达式" 和 "限定匹配次数"。
      # 正则和限定次数逻辑都会失效，并匹配文件每一行。
      # 好在这种情况比较少见，暂时不做处理。(没想到怎么处理...)
        ##############################################################################################
      if [[ $(yxct_os_type) == 'osx' ]]; then
          # 因为sed在OSX上的问题，这里不得不换行!!!
        # sed -i "" "0,/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
        # ${sed_fixkey} = ${sed_fixval}\\
        # " "${file}"
        sed -i "" "/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
        ${sed_fixkey} = ${sed_fixval}\\
        " "${file}"
      else
        # sed -i "0,/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${sed_fixval}" "${file}"
        sed -i "/^[[:space:]]*#\+[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${sed_fixval}" "${file}"
      fi
    fi
  else
    echo -e "\n\n${key}${space}=${space}${val}\n" >> "${file}"
  fi  
}



###########################################################
# Utility
###########################################################

function yxct_get_library_path()
{
  local lib_path=
  if [[ $(yxct_os_type) == 'osx' ]]; then
    lib_path="/usr/local/yuxi"
  else
    lib_path="/usr/yuxi"
  fi

  echo "${lib_path}"
}

function yxct_get_default_cache_path()
{
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi

  echo "${library_path%\/}/${CMD}/cache"
}

function yxct_get_cmd_item()
{
  local type=
  while [ $# -gt 0 ]; do
    case $1 in
      
      --cache )
       type=$1
      ;;

      --config )
       type=$1
      ;;

      --index )
       type=$1
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done

  # get cellar_path
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi

  local result=0
  if [[ "${type}" == '--cache' ]]; then
    result="${library_path%\/}/${CMD}/cache"
  elif [[ "${type}" == '--config' ]]; then
    result="${library_path%\/}/${CMD}/conf"
  elif [[ "${type}" == '--index' ]]; then
    result="${library_path%\/}/${CMD}/index"
  fi
  
  echo "${result}"
  [ -n "${result}" ] && return 0 || return 1
}


#usage
# yxct_git_repo update --repo <repo-path> --addr <git-addr>
#usage
# yxct_git_repo checkout <git-hash> --repo <repo-path> --addr <git-addr>
#
# return value
# update:
# 0:success
# 11:already the last version
# checkout
# 0:success
# 
function yxct_git_repo()
{
  local repo_path=
  local git_address=
  local git_hash=

  local operation=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    if yxct_strcontains "$1" 'checkout' --ignorecase; then
      operation='CHECKOUT'
      if [ -n "$2" ] && [[ "$2" =~ ^[0-9a-zA-z]{7,40}$ ]]; then
        git_hash=$2
        shift
      else
        yxct_fatal "use 'checkout' but not provide a git-hash value"
      fi
    elif yxct_strcontains "$1" 'update' --ignorecase; then
      operation='UPDATE'
    else
      operation=$1
    fi
    shift
  fi



  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
      --repo )
        cursor=$1
      ;;

      --addr )
        cursor=$1
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--repo' ]]; then
            repo_path=$(echo "${repo_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--addr' ]]; then
            git_address=$(echo "${git_address} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yx_fatal "invalid optional ${1}"
        fi
    esac
    shift
  done

  if [ -z "${repo_path}" ]; then
    yxct_fatal "repo path is empty"
  fi

  # yxct 预计的环境，很大可能是没有git的...
  if ! which git > /dev/null; then
    yxct_fatal "can not find git command."
  fi



  function __yxct_valid_repo()
  {
    local git_addr=$1
    local valid=true

    # check the directory is a git repo.
    if ${valid}; then
      if ! [ -d "${repo_path}" ]; then
        valid=false
      elif ! [ -d "${repo_path}/.git" ]; then
        valid=false
      elif ! git -C "${repo_path}" rev-parse --git-dir &> /dev/null; then
        valid=false
      else
        local git_flag=
        if git_flag=$(git -C "${repo_path}" rev-parse --git-dir 2> /dev/null); then
          if [[ "${git_flag}" != '.git' ]]; then
            git_flag=false
          fi
        else
          valid=false
        fi
        
      fi
    fi


    # check the git address is same with '--address params'
    if ${valid}; then
      if [ -n "${git_addr}" ]; then
        local repo_git_addr=$(git -C "${repo_path}" remote -v | grep -i '\\(fetch\)' | awk '{print $2}')
        if [[ "${git_addr}" != "${repo_git_addr}" ]]; then
          valid=false
        fi
      fi
    fi

    ${valid} && return 0 || return 1
  }

  function __yxct_clean_repo()
  {
    # get repo status
    local git_status=
    if ! git_status=$(git -C "${repo_path}" status --porcelain=v1); then
      yxct_fatal "failed to get git status"
    fi

    # clean the repo if need
    if [ -n "${git_status}" ]; then
      yxct_msg "the repo is dirty, try recover..."
      
      # clean the repo
      yxct_verbcmd "git -C ${repo_path} reset --hard HEAD --"
      yxct_verbcmd "git -C ${repo_path} clean -fd"
      
      # check clean result
      if ! git_status=$(git -C "${repo_path}" status --porcelain=v1); then
        yxct_fatal "failed to get git status after clean yxct repo"
      fi
      if [ -n "${git_status}" ]; then
        yxct_fatal "failed to clean ${CMD} repo"
      fi
    fi
  }

  function __yxct_clone_new_repo()
  {
    # remove old repo directory if exist
    if [ -d "${repo_path}" ]; then
      yxct_verbcmd "${RM} -rf ${repo_path}"
      if [ -d "${repo_path}" ]; then
        yxct_verbcmd "failed to remove old repo directory"
      fi
    fi

    # create the repo directory
    if ! yxct_verbcmd "${MKDIR} -p ${repo_path}"; then
      yxct_fatal "failed to create repo directory"
    fi

    # clone a new repo
    if ! git clone "${git_addr}" "${repo_path}"; then
      yxct_fatal "failed to clone a new repo."
    fi
  }


  local result=0
  if [[ "${operation}" == 'CHECKOUT' ]]; then

    yxct_msg "check local git repo directory..."
    if __yxct_valid_repo "${git_address}"; then
      # clean the repo
      yxct_msg "clean local repo directory..."
      __yxct_clean_repo
    else
      # clone a new repo
        yxct_msg "clone a new repo..."
      __yxct_clone_new_repo
    fi

    # checkout the repo on specific git-hash.
    yxct_msg "checkout repo HEAD to ${git_hash}..."
    if ! yxct_verbcmd "git -C ${repo_path} checkout ${git_hash}"; then 
      yxct_fatal "failed to checkout the repo on:${git_hash}"
    fi

    result=0

  elif [[ "${operation}" == 'UPDATE' ]]; then
    
    yxct_msg "check local git repo directory..."
    if __yxct_valid_repo "${git_address}"; then

      # git fetch
      yxct_msg "check update info..."
      yxct_verbcmd "git -C ${repo_path} fetch"
      echo "here"

      # check whether need update
      local git_head=$(git -C "${repo_path}" log HEAD | head -n 1 | awk '{print $2}')
      local git_fetch_head=$(git -C "${repo_path}" log FETCH_HEAD | head -n 1 | awk '{print $2}')
      if [[ "${git_head}" != "${git_fetch_head}" ]]; then

        # clean the repo
        __yxct_clean_repo

        yxct_msg "begin update..."
        #pull the repo
        if ! yxct_verbcmd "git -C ${repo_path} pull"; then
          yxct_fatal "failed to pull repo"
        fi

        result=0
      else
        # is already the latest version"
        result=11
      fi

    else
      # clone a new repo
      yxct_msg "clone a new repo..."
      if ! __yxct_clone_new_repo; then
        yxct_fatal "failed to clone new repo"
      fi
      result=0
    fi

  else
    yxct_fatal "unknown opton:${operation}"
    result=1
  fi


  return "${result}"
}


function yxct_get_cellar_item()
{
  local command=
  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "empty command on cellar item"
  fi


  local type=
  while [ $# -gt 0 ]; do
    case $1 in
      
      --setup-script )
       type=$1
      ;;

      --command-hash )
       type=$1
      ;;

      --cellar-path )
       type=$1
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done


  # get cellar_path
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi


  local result=0
  local cellar_path="${library_path%\/}/${CMD}/cellar/${command}"
  if [[ "${type}" == '--setup-script' ]]; then
    if [ -f "${cellar_path}/.${CMD}.setup.sh" ]; then
      echo "${cellar_path}/.${CMD}.setup.sh"
    elif [ -f "${cellar_path}/.${CMD}.setup.py" ]; then
      echo "${cellar_path}/.${CMD}.setup.py"
    elif [ -f "${cellar_path}/.${CMD}.setup.rb" ]; then
      echo "${cellar_path}/.${CMD}.setup.rb"
    else
      result=1
    fi
  elif [[ "${type}" == '--command-hash' ]]; then
    if [ -f "${cellar_path}/hash" ]; then
      grep -o "[^ ]\+\( \+[^ ]\+\)*" "${cellar_path}/hash"
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--cellar-path' ]]; then
    echo "${cellar_path}"
  else
    echo "${cellar_path}"
  fi

  return ${result}
}


function setup_cellar()
{
  local command=

  local install_script=
  local install_file=

  local option=
  if yxct_strcontains "$1" "install" --ignorecase; then
    option='INSTALL'
    shift
  elif yxct_strcontains "$1" "uninstall" --ignorecase; then
    option='UNINSTALL'
    shift
  else
    yxct_fatal "unknown option in setup cellar"
  fi

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi


  while [ $# -gt 0 ]; do
    case $1 in

      --install-file )
        shift
        install_file=$1
      ;; 

      --install-script )
        shift
        install_script=$1
      ;; 

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done


  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi


  local cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)
  if [ -z "${cellar_path}" ]; then
    yxct_fatal "failed to get cellar path of command:${command}"
  fi


  if [[ "${option}" == 'INSTALL' ]]; then

    # create cellar dir
    if [ -d "${cellar_path}" ]; then
      yxct_err "cell path already exist, try remove it:${cellar_path}"
      if ! yxct_verbcmd "${RM} -rf ${cellar_path}"; then
        yxct_fatal "failed to remove old cellar dir:${cellar_path}"
      fi
    fi

    if ! yxct_verbcmd "${MKDIR} -p ${cellar_path}"; then
      yxct_fatal "failed to create dir:${cellar_path}"
    fi

    # copy file
    if [ -n "${install_script}" ]; then
      if [ -f "${install_script}" ]; then
        yxct_verbcmd "${CP} ${install_script} ${cellar_path}"
      else
        yxct_fatal "can not find a install script on setup cellar"
      fi
    fi

    if [ -n "${install_file}" ]; then
      if [ -f "${install_file}" ]; then
        local install_file_hash=$(shasum -a 256 "${install_file}" | awk '{print $1}')
        if [ -n "${install_file_hash}" ]; then
          echo "${install_file_hash}" > "${cellar_path}/hash"
        else
          yxct_fatal "failed to calculate the hash value on install file:${install_file}"
        fi
      else
        yxct_fatal "can not find a install file on setup cellar"
      fi
    fi

  elif [[ "${option}" == 'UNINSTALL' ]]; then
    if [ -d "${cellar_path}" ]; then
      yxct_verbcmd "${RM} -rf ${cellar_path}"
    fi
  else
    yxct_fatal "unknown option:${option}"
  fi

}

function yxct_set_info_level()
{
  local info_level=$1
  if [ -n "${info_level}" ]; then

    if ${YXCT_USEYXLIB}; then
      yx_logger set --output-level "${info_level}"
    fi

    if yxct_str_checkfmt '^([0-9])+$' "${info_level}"; then
      YXCT_DEFAULT_LEVEL="${info_level}"
      export YXLOGGER_DEFAULT_LEVEL="${info_level}"
    elif yxct_strcontains "${info_level}" 'silent' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_SILENT}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_SILENT}"
    elif yxct_strcontains "${info_level}" 'fatal fat' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_FATAL}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_FATAL}"
    elif yxct_strcontains "${info_level}" 'error err' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_ERROR}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_ERROR}"
    elif yxct_strcontains "${info_level}" 'warning warn' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_WARN}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_WARN}"
    elif yxct_strcontains "${info_level}" 'info msg' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_INFO}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_INFO}"
    elif yxct_strcontains "${info_level}" 'verbose verb' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_VERBOSE}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_VERBOSE}"
    elif yxct_strcontains "${info_level}" 'debug' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_DEBUG}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_DEBUG}"
    elif yxct_strcontains "${info_level}" 'trace' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_TRACE}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_TRACE}"
    elif yxct_strcontains "${info_level}" 'all' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_ALL}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_ALL}"
    else
      yxct_fatal "unknown info level :${info_level}"
    fi # end of (if yx_check_strfmt '^([0-9])+$' "${info_level}"; then)

  fi # end of 'if [ -n ${info_level} ]'
}


function is_in_reg_list()
{
  local name=$1
  shift
  local reg_list=($@)
  
  if [[ "${reg_list}" ]]; then
    for reg in "${reg_list[@]}"; do
      reg=$(echo "${reg}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
      if echo "${name}" | grep -Eqi "${reg}"; then
        return 0
      fi
    done
  fi
  
  return 1
}


# 如果目录下只有一个文件，则返回
# 1. 会忽略 IGNORE_LIST 列表里正则对应的文件
# 2. 会忽略 --ignore 参数中正则列表对应的文件
# usage: file_name_if_single <目录>
# usage: file_name_if_single <目录> --ignore '正则1' '正则2' ....
function file_name_if_single()
{
  local script_path=$1
  local -a ignore_reg_list
  if [[ $2 == '--ignore' ]]; then
    shift # ignore $1
    shift # ignore --ignore
    ignore_reg_list=($@)
  fi

  
  local -a valid_files
  # local SAVEIFS=$IFS
  for file in "${script_path%\/}"/*; do

    if [[ ${file} =~ ^"${script_path%\/}"/*$ ]]; then
      continue
    fi

    local filename=$(basename  "${file}")    

    # 文件名在忽略列表里
    if is_in_reg_list "${filename}" ${ignore_reg_list[@]}; then
      continue
    fi

    if ! is_in_reg_list "${filename}" ${IGNORE_LIST[@]}; then
      valid_files=(${valid_files[@]} "${filename}")
    fi
    
  done
  # IFS=${SAVEIFS}
  
  if [[ "${#valid_files[@]}" == 1 ]]; then
    echo "${valid_files[@]}"
    return 0
  else
    return 1
  fi
}

function search_file_by_reg_list()
{
  local script_path=$1
  shift
  local reg_list=($@)

  # local SAVEIFS=$IFS


  # search regular files
  for file in "${script_path%\/}"/*; do

    if [[ ${file} =~ ^"${script_path%\/}"/*$ ]]; then
      continue
    fi

    local filename=$(basename "${file}")    
    if is_in_reg_list "${filename}" ${reg_list[@]}; then
      echo "${filename}"
      return 0
    fi
  done

  # search regular invisiable files 
  for file in "${script_path%\/}"/.*; do
    if [[ ${file} == ${script_path%/}/\* ]]; then
      continue
    fi

    local filename=$(basename "${file}")    
    if [[ ${filename} == '.' ]] || [[ ${filename} == '..' ]]; then
      continue
    fi

    if is_in_reg_list "${filename}" ${reg_list[@]}; then
      echo "${filename}"
      return 0
    fi
  done


  # IFS=${SAVEIFS}

  return 1
}


# function is_same_file()
# {
#   local file1=$1
#   local file2=$2

#   local file1_hash=
#   if [ -r "${file1}" ]; then
#     file1_hash=$(shasum -a 256 "${file1}")
#   fi

#   local file2_hash=
#   if [ -r ${file2} ]; then
#     file2_hash=$(shasum -a 256 "${file2}")
#   fi

#   if [[ -f "${file1}" ]] && [[ -f "${file2}" ]]; then
#     if [[ "${file1}" -eq "${file2}" ]]; then
#       return 0
#     fi
#   fi

#   return 1
# }


function check_file_hash()
{
  local file=$1
  local hash=$2

  if ! [ -r "${file}" ]; then
    yxct_fatal "Can not read the file:${file}"
  fi

  if [ -z "${hash}" ]; then
    yxct_fatal "hash is empty."
  fi

  local file_hash=$(shasum -a 256 "${file}" | awk '{print $1}')
  if [[ "${file_hash}" == "${hash}" ]]; then
    return 0
  else
    return 1
  fi
}

# 执行卸载脚本
function run_setup_script()
{
  local script_path=
  local bin_path=
  local additional=
  local all=false

  local option=$1
  if yxct_strcontains "${option}" 'install' --ignorecase; then
    option="install"
    shift
  elif yxct_strcontains "${option}" 'uninstall' --ignorecase; then
    option="uninstall"
    shift
  else
    yxct_fatal "option is empty."
  fi

  while [ $# -gt 0 ]; do
    case $1 in
      --path )
        shift
        script_path=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --all )
        all=true
      ;;


      *)
        additional="${additional} $1"
    esac
    shift
  done


  if ! [ -f "${script_path}" ]; then
    yxct_fatal "setup script not exist :${script_path}"
  fi
  
  if ! [ -x "${script_path}" ]; then
    yxct_err "Setup script does not have execution permissions. try add one."
    yxct_verbcmd "chmod +x ${script_path}"
  fi

  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi


  # 因为运行脚本，很可能使用了YXLib库，这里让运行脚本
  # 这里了设置yxlogger的环境变量
  local saved_yxlib_log_echo_level="${YXLOGGER_DEFAULT_LEVEL}"
  if [ -n "${YXCT_DEFAULT_LEVEL}" ]; then
    # 保存之前的环境变量
    export YXLOGGER_DEFAULT_LEVEL="${YXCT_DEFAULT_LEVEL}"
  fi


  local result
  if [ -n "${bin_path}" ]; then
  # 如果给了bin_path, 则按照 bin_path 给卸载脚本
    pushd $(dirname "${script_path}") > /dev/null
    yxct_run_script "${script_path} ${option} --bin-path ${bin_path} --lib-path ${library_path} ${additional}"
    result="$?"
    popd > /dev/null

    if [[ "${result}" != '0' ]]; then
      yxct_fatal "Failed to run setup script: ${script_path}"
    fi
  elif which "${command}" > /dev/null; then
  # else
  # 如果能找到 command, 根据command获得bin-path
    while true; do

      local finded_exec_path=$(which "${command}")
      if [ -z "${finded_exec_path}" ]; then
        break
      fi
      
      local bin_path=$(dirname "${finded_exec_path}")

      pushd $(dirname "${script_path}") > /dev/null
      yxct_run_script "${script_path} ${option} --bin-path ${bin_path} --lib-path ${library_path} ${additional}"
      result="$?"
      popd > /dev/null    

      if [[ "${result}" != '0' ]]; then
        yxct_fatal "Failed to run setup script: ${script_path}"
      fi

      if ! ${all}; then
        break
      fi
    done
  
  else
    # 如果没找到command, 完全不知道 --bin-path , 直接调用脚本
    pushd $(dirname "${script_path}") > /dev/null
    yxct_run_script "${script_path} ${option} --lib-path ${library_path} ${additional}"
    result="$?"
    popd > /dev/null

    if [[ "${result}" != '0' ]]; then
      yxct_fatal "Failed to run setup script: ${script_path}"
    fi
  fi


  # 这里要还原 YXLOGGER_DEFAULT_LEVEL
  # 使用和备份时相同的判断条件
  if [ -n "${YXCT_DEFAULT_LEVEL}" ]; then
    export YXLOGGER_DEFAULT_LEVEL="${saved_yxlib_log_echo_level}"
  fi



  # pushd $(dirname "${script_path}") > /dev/null
  # yxct_run_script "${script_path} ${option} ${additional}"
  # result="$?"
  # popd > /dev/null

  # if [[ "${result}" != '0' ]]; then
  #   yxct_fatal "Failed to run setup script: ${script_path}"
  # fi

  return ${result}
}

# 根据命令名直接卸载可执行文件
function remove_command()
{
  local all=false
  local command=
  local hash=

  while [ $# -gt 0 ]; do
    case $1 in
      --command )
        shift
        command=$1
      ;; 

      --hash )
        shift
        hash=$1
      ;; 

      --all )
        all=true
      ;; 
    esac
    shift
  done

  if [ -z "${command}" ]; then
    yxct_fatal "Command is empty !"
  fi


  # 提前额外验证一下， while循环里的验证不能抱错误警告
  if ! $(which "${command}" > /dev/null); then
    yxct_fatal "Can not find the command:${command}"
  fi

  while true; do
    local finded_exec_path=$(which "${command}")
    if [ -z "${finded_exec_path}" ]; then
      break
    fi

    if ! [ -w ${finded_exec_path} ]; then
     yxct_fatal "Have not permission to remove the file:${finded_exec_path}"
    fi

    if [ -n "${hash}" ]; then
      if ! check_file_hash "${finded_exec_path}" "${hash}"; then
        break
      fi
    fi

    # 强制删除命令
    yxct_verbcmd "${RM} -f ${finded_exec_path}"
    if [[ $? != '0' ]]; then
      yxct_fatal "Fail to uninstall '${command}'"
    fi

    if ! ${all}; then
      break
    fi

  done

  # remove setter
  setup_cellar uninstall "${command}"

  return 0
}

# 根据一个可执行文件，查找安装的命令，并卸载
# 可执行文件仅用于 hash验证
# 查找方式
# 1. which ${command}
# 2. bin_path/command 或 bin_path/$(basename command)
function remove_by_hash_file()
{
    local file_path=
    local bin_path=
    local command=
    local all=false

    while [ $# -gt 0 ]; do
      case $1 in
        --path )
          shift
          file_path=$1
        ;;

        --bin-path )
          shift
          bin_path=$1
        ;;

        --command )
          shift
          command=$1
        ;; 

        --all )
          all=true
        ;; 
      esac
      shift
    done

    if ! [ -f "${file_path}" ]; then
      yxct_fatal "File not exist :${file_path}"
    fi
    local file_hash=$(shasum -a 256 "${file_path}" | awk '{print $1}' )
    if [ -z "${file_hash}" ]; then
      yxct_fatal "Failed to calculate the hash value of the file:${file_path}"
    fi

    local filename=$(basename "${file_path}")
    # 如果提供了命令名，脚本名字和命令名必须相同
    if [ -n "${command}" ] && [ "${filename}" != "${command}" ]; then
      yxct_fatal "Filename name and command not matched."
    fi

    if [ -n "${bin_path}" ]; then

      local finded_exec_path=
      if [ -n "${command}" ]; then
        finded_exec_path="${bin_path}/${command}"
      else
        finded_exec_path="${bin_path}/${filename}"
      fi

      if ! [ -f ${finded_exec_path} ]; then
        yxct_fatal "Can not find a command at:${finded_exec_path}"
      fi

      # 要删除的文件必须和传入的文件相同
      if ! check_file_hash "${finded_exec_path}" "${file_hash}"; then
        yxct_fatal "Script and execute file not matched:(${execute_file_path})"
      fi

      # 强制删除命令
      yxct_verbcmd "${RM} -f ${execute_file_path}"
      if [[ $? != 0 ]]; then
        yxct_fatal "Fail to uninstall '${command}' in path:${bin_path}"
      fi
   else
     local params=''
     if "${all}"; then
       arams="${params} --all"
     fi

     remove_command --command "${filename}" --hash "${file_hash}" ${params}
   fi
}


function install_file()
{
  local file_path=
  local bin_path=
  local command=
  local force=false

  while [ $# -gt 0 ]; do
    case $1 in
      --file )
        shift
        file_path=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --command )
        shift
        command=$1
      ;;

      --force )
        force=true
      ;;
    esac
    shift
  done

  if [ -z "${file_path}" ]; then
    yxct_fatal "file path is empty."
  fi

  if ! [ -r "${file_path}" ]; then
    yxct_fatal "Can not read file:${file_path}"
  fi

  if [ -z ${bin_path} ]; then
    yxct_fatal "destination path is empty."
  fi

  if [ -z "${command}" ]; then
    command=$(basename "${file_path}")
  fi

  local dest_path="${bin_path}/${command}"

  # 在没有指定--force时，如果目标文件已存在，且和要考呗的文件不同，则fatal
  if [ -f "${dest_path}" ] && ! ${force}; then
    local file_hash=$(shasum -a 256 "${file_path}" | awk '{print $1}')
    if ! check_file_hash "${dest_path}" "${file_hash}"; then
      yxct_fatal "file already exist on dest path:${dest_path}. Use --force to overwrite the exist file"
    fi
  fi


  # 之前已经验证过 force了，这里仍然判断force参数， 避免多脚本同时执行
  local force_params=''
  if ${force}; then
    force_params='-f'
  fi

  yxct_verbcmd "${CP} ${force_params} ${file_path} ${bin_path}/${command}"
}


# 根据安装脚本路径，卸载可执行文件
function uninstall_by_script_path()
{
  local script_path=
  local additional=
  local bin_path=
  local command=

  local -a ignore_reg_list=
  local all=false

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in
      --path )
        shift
        script_path=$1
      ;;

      --command )
        shift
        command=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --all )
        all=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
    esac
    shift
  done

  if [ -z "${script_path}" ]; then
    yxct_fatal "Script path is empty."
  fi

  # local all_params=''
  # if "${all}"; then
  #   all_params='--all'
  # fi

  local params=''
  #--command
  if [ -n "${command}" ]; then
    params="${params} --command ${command}"
  fi

  if [ -n "${bin_path}" ]; then
    params="${params} --bin-path ${bin_path}"
  fi

  if ${all}; then
    params="${params} --all"
  fi
  

  local result=1
  if [ -f "${script_path}" ]; then
  # 如果脚本路径是一个文件

    local script_file_name=$(basename "${script_path}")
    if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
    # 如果文件是一个安装脚本, 直接调用脚本
      run_setup_script uninstall --path "${script_path}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    else
      # 如果文件不是安装脚本，尝试使用 command 和 bin_path卸载。 并用这个文件做hash验证并卸载，并删除
      remove_by_hash_file --path "${script_path}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    fi
  elif [ -d "${script_path}" ]; then
  # 如果脚本路径是一个目录
    local uninstall_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
    if [[ -n "${uninstall_script_filename}" ]]; then
    # 如果目录中找到安装脚本, 直接掉用那个安装脚本
      run_setup_script uninstall --path "${script_path%\/}/${uninstall_script_filename}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    else
    # 没找到那个安装脚本，查看是否是单脚本APP
      local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
      if [ -n "${singl_app_name}" ]; then
        # 如果文件夹下只找到一个文件，尝试使用 command 和 bin_path卸载。并使用这个文件做 hash 验证.
        remove_by_hash_file --path "${script_path%\/}/${singl_app_name}" ${params} ${additional}
        result=$?
        setup_cellar uninstall "${command}"
      else
        # 如果不是单脚本APP, 不知道如何安装
        yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to delete the command."
      fi
    fi
  else
  # 既不是文件，也不是目录，无效script_path
    yxct_fatal "Invalid script path:${script_path}"
  fi

  return "${result}"
}


# 根据可执行文件路径，卸载这个可执行文件
function uninstall_by_bin_path()
{
  local bin_path=
  local command=
  local additional=
  
  # 这个函数被调用，说明script_path 必定为空，之前判断过了

  while [ $# -gt 0 ]; do
    case $1 in
      --path )
        shift
        bin_path=$1
      ;;

      --command )
        shift
        command=$1
      ;; 

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done



  if [ -f "${bin_path}" ]; then
  # 如果bin_path 是个文件, 直接删除， command 提供验证
    if [ -n "${command}" ]; then
      local filename=$(basename "${bin_path}")
      if [[ "${filename}" != "${command}" ]]; then
        yxct_fatal "Filename name '${filename}' and command '${command}' not matched."
      fi

      local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
      if [ -n "${cellar_hash}" ]; then
        if ! check_file_hash "${bin_path}" "${cellar_hash}"; then
          yxct_fatal "failed to check hash value for execute file:${bin_path}"
        fi
      fi

        # # 要删除的文件必须和传入的文件相同
        # if ! check_file_hash "${finded_exec_path}" "${file_hash}"; then
        #   yxct_fatal "Script and execute file not matched:(${execute_file_path})"
        # fi
      # fi

    fi

    # 强制删除命令
    yxct_verbcmd "${RM} -f ${bin_path}"
    if [[ $? != 0 ]]; then
      yxct_fatal "Fail to uninstall '${command}' on path:${bin_path}"
    fi
    setup_cellar uninstall "${command}"
  elif [ -d "${bin_path}" ]; then
  # 如果bin_path 是个目录, 则command 不能为空, 根据command删除

    if [ -z "${command}" ]; then
      yxct_fatal "Can not find any script in path ${bin_path}"
    fi

    if ! [ -f "${execute_file_path}" ]; then
      echo_file "Script does not exist:${execute_file_path}"
    fi

    local execute_file_path="${bin_path}/${command}"
    local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
    if [ -n "${cellar_hash}" ]; then
      if ! check_file_hash "${execute_file_path}" "${cellar_hash}"; then
        yxct_fatal "failed to check hash value for execute file:${execute_file_path}"
      fi
    fi

    # 强制删除命令
    yxct_verbcmd "${RM} -f ${execute_file_path}"
    if [[ $? != 0 ]]; then
      yxct_fatal "Fail to uninstall '${command}' in path:${bin_path}"
    fi
    setup_cellar uninstall "${command}"
  else
    # 既不是文件，也不是目录，无效bin_path
    yxct_fatal "Invalid path:${bin_path}"
  fi

  return 0
}



function search_in_index()
{
  local command=
  local key=

  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi

  while [ $# -gt 0 ]; do
    case $1 in
      --key )
        shift
        key=$1
      ;;

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done

  local index_path=$(yxct_get_cmd_item --index)
  if [ -z "${index_path}" ]; then
    yxct_fatal "failed to get index path"
  fi

  # git addr
  local git_addr=$(cmd_config read --key index.repo)
  if [ -z "${git_addr}" ]; then
    git_addr="${YXCT_INDEX_DEFAULT_GIT_ADDR}"
  fi

  # branch
  local git_branch=$(cmd_config read --key index.branch)
  if [ -z "${git_branch}" ]; then
    git_branch="${YXCT_INDEX_DEFAULT_GIT_BRANCH}"
  fi

  # repo folder name
  local index_dir_name=
  if [[ $(yxct_os_type) == 'osx' ]]; then
    index_dir_name=$(echo "${git_addr}#${git_branch}" | md5)
  else
    index_dir_name=$(echo "${git_addr}#${git_branch}" | md5sum | awk '{print $1}')
  fi

  # repo dir
  local index_config="${index_path%\/}/${index_dir_name}/${command}.conf"
  if [ -f "${index_config}" ]; then
    yxct_config_read --file "${index_config}" --key "${}"
  fi
}


function update_index_if_need()
{
  # local need_update=false
  local index_path=$(yxct_get_cmd_item --index)
  if [ -z "${index_path}" ]; then
    yxct_fatal "failed to get index path"
  fi

  # last update timestamp
  local last_timestamp_file="${index_path}/last"


  if ! [ -d "${index_path}" ]; then
    # need_update=true
    yxct_verbcmd "${MKDIR} -p ${index_path}"
    if ! [ -d "${index_path}" ]; then
      yxct_fatal "failed to create index directory"
    fi
  fi

  #check whether should update index repo
  local should_update=true

  # check update flag
  if ${should_update}; then
    local update=$(cmd_config read --key index.update)
    if [ -n "${update}" ]; then
      if yxct_strcontains "${update}" "no 0 false" --ignorecase; then
        should_update=false
      fi
    fi
  fi


  # check schedule
  if ${should_update}; then

    # get schedule
    local schedule=$(cmd_config read --key index.schedule)
    if [ -z "${schedule}" ]; then
      schedule="${YXCT_INDEX_DEFAULT_SCHEDULE}"
    fi
    local schedule_in_seconds=$(yxct_datastr_to_second "${schedule}")

    # get current timestamp
    local current=$(date '+%s')
    if [ -z "${current}" ]; then
      yxct_fatal "failed to get current timestamp"
    fi

    # get last update timestamp
    if [ -f "${last_timestamp_file}" ]; then

      local last=$(cat "${last_timestamp_file}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
      if [ -z "${last}" ]; then
        : # 上次更新时间戳不存在，不需要验证
      elif [[ "${last}" =~ ^[0-9]{10}$ ]]; then
        # check schedule
        if [ $((current-last)) -lt "${schedule_in_seconds}" ]; then
          should_update=false
        fi
      else
        # 上次更新时间戳，格式不对。报个error, 然后忽略时间戳
        yxct_err "invalid last update timestamp in index repo"
      fi

    fi
  fi


  if ${should_update}; then
    
    # git addr
    local git_addr=$(cmd_config read --key index.repo)
    if [ -z "${git_addr}" ]; then
      git_addr="${YXCT_INDEX_DEFAULT_GIT_ADDR}"
    fi

    # branch
    local git_branch=$(cmd_config read --key index.branch)
    if [ -z "${git_branch}" ]; then
      git_branch="${YXCT_INDEX_DEFAULT_GIT_BRANCH}"
    fi

    # repo folder name
    local index_dir_name=
    if [[ $(yxct_os_type) == 'osx' ]]; then
      index_dir_name=$(echo "${git_addr}#${git_branch}" | md5)
    else
      index_dir_name=$(echo "${git_addr}#${git_branch}" | md5sum | awk '{print $1}')
    fi

    # repo dir
    local repo="${index_path%\/}/${index_dir_name}"

    # update index repo
    yxct_git_repo update --repo "${repo}" --addr "${repo}"
    local result=$?
    if [[ "${result}" == '0' ]]; then
      yxct_msg "update success"
    elif [[ "${result}" == '1' ]]; then
      yxct_msg "${CMD} is already the latest version"
    else
      yxct_fatal "update failed"
    fi

  fi # end of (if ${should_update}; then)

}


function search_in_cache()
{
  local command=$1
  shift
  local cache_path="$*"

  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi

  local result=
  if [ -d "${cache_path}" ]; then
    if [ -f "${cache_path%\/}/${command}" ] || [ -d "${cache_path%\/}/${command}" ]; then
      # cache 下, 命令安装包可以是文件或文件夹
      result="${cache_path%\/}/${command}"
    elif [ -f "${cache_path%\/}/${command}.yxct" ]; then
      # cache 下, 是 package
      result="${cache_path%\/}/${command}.yxct"
    fi
  elif [ -f "${cache_path}" ]; then
    local file_name=$(basename "${cache_path}")
    if [[ "${file_name}" == "${command}" ]] || [[ "${file_name}" == "${command}.yxct" ]]; then
      result="${cache_path}"
    fi
  fi

  echo "${result}"
}

function checkout_a_cache()
{
  local version=
  local githash=
  local cache_path=

  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi

  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
      --version )
        cursor=$1
      ;;

      --hash )
        cursor=$1
      ;;

      --cache-dir )
        cursor=$1
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi

        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--version' ]]; then
            version=$(echo "${version} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--hash' ]]; then
            githash=$(echo "${githash} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--cache-dir' ]]; then
            cache_path=$(echo "${cache_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yx_fatal "invalid optional ${1}"
        fi

    esac
    shift
  done

  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi

  if [ -z "${cache_path}" ]; then
    yxct_fatal "chache directory is empty"
  fi


  # checkout the version
  if [ -z "${githash}" ]; then

    # get the version if --version params not provide
    if [ -z "${version}" ]; then
      version=$(search_in_index "${command}" --key "${latest}")
      if [ -z "${version}" ]; then
        yxct_fatal "failed to get latest version:${version} of command:${command}"
      fi
    fi

    # get git-has with the 'version'
    githash=$(search_in_index "${command}" --key "${version}")
    if [ -n "${githash}" ]; then
      yxct_fatal "unknown version:${version} of command:${command}"
    fi

  fi

  # get git address
  lcoal gitaddr=$(search_in_index "${command}" --key 'repo')
  if [ -z "${gitaddr}" ]; then
    yxct_fatal "failed to find a git address from the index config file of '${command}' command."
  fi


  local repo="${cache_path%\/}/${command}"

  yxct_git_repo checkout "${githash}" --repo "${repo}" --addr "${gitaddr}"

}


###########################################################
# Usage
###########################################################

function yxct_usage()
{
cat <<EOF
  usage: ${CMD} <sub-command> <optional>
  Manage command tool

  usage: ${CMD} <sub-command> <--help|-h>
  For detail information for sub-command.

  usage: ${CMD} --help
  For this help information

  The following sub-command are allowed:
  install:      Install a command tool.
  uninstall:    Uninstall a command tool.
  reinstall:    Reinstall a command tool.
  update:       Update to newest version of ${CMD}
  pack:         Create or extra a ${CMD} package.
  list:         list all installed command.

  Other options
  Use '${CMD} uninstall --help' show this help information
EOF
}

function yxct_usage_install()
{

  function __usage_install_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be install to'/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install
        the command to '/usr/local/bin' as default.
  
  Un-support destination options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be install to '/bin'
  --sbin                    The command will be install to '/sbin'
  --usr-bin                 The command will be install to '/usr/bin'
  --usr-local-bin           The command will be install to '/usr/local/bin'
  --usr-local-sbin          The command will be install to '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install the
        command to '/usr/local/bin' as default.
EOF
    fi
  }


cat <<EOF
  usage: ${CMD} install <command> <optional>
  Install a command

  usage: ${CMD} install --help
  Show this help information

  The following options are availiable:
  --path <path>             1. Point to an install script or a folder that contains an install script.
                            2. Point to a command file, ${CMD} will try to install the command to system.
                            3. point to ${CMD} package with a 'yxct' extension or a folder that contains
                            the package (You can create a ${CMD} package with '${CMD} pack' command, or use
                            '${CMD} pack --help' to see more information).
  --cache [path]            Command will be install from cache directory. If the --cache parameter does not
                            provide a path. ${CMD} will try to find it from 'YXCT_CACHE_PATH' environment.
                            '--cache' has a lower priority than '--path'. If a valid '--path' parameter is
                            specified, the '--cache' parameter is ignored.
  
  --pass <pass>             When installing through a package, if the package requires a password,
                            you can provide it with '--pass' parameter. If the package requires a password,
                            but the '--pass' parameter is not used. ${CMD} will ask for the password during
                            the installation process

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no install
                            script there. ${CMD} will not be able to determine which script to install.
                            use '--ignore' and indicate regulars expression to ignore useless files.
  
  --force                   If an existing file on bin-path, remove it.


  The followint options indicate destination path:
$(__usage_install_destination_info)
  

  The followint options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} install --help' show all help information
EOF
}

function yxct_usage_uninstall()
{

  function __usage_install_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be uninstall from '/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as target path.

  Note: If indicate a target path but the command not installed on that path, ${CMD} will do
        nothing and raise an error.
  
  Un-support target options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be uninstall from '/bin'
  --sbin                    The command will be uninstall from '/sbin'
  --usr-bin                 The command will be uninstall from '/usr/bin'
  --usr-local-bin           The command will be uninstall from '/usr/local/bin'
  --usr-local-sbin          The command will be uninstall from '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as target.

  Note: If indicate a target path but the command not installed on that path, ${CMD} will do
        nothing and raise an error.
EOF
    fi
  }

cat <<EOF
  usage: ${CMD} uninstall <command> <optional>
  Uninstall a command

  usage: ${CMD} uninstall --help
  Show this help information

  The following options are availiable:
  --path <path>             1. point to an uninstall script or a folder that contains an uninstall script.
                            2. point to a command file, ${CMD} will try to uninstall a same command on system.
                            3. point to ${CMD} package with a 'yxct' extension or a folder that contains
                            the package (You can create a ${CMD} package with '${CMD} pack' command, or use
                            '${CMD} pack --help' to see more information).
  
  --pass <pass>             When installing through a package, if the package requires a password,
                            you can provide it with '--pass' parameter. If the package requires a password,
                            but the '--pass' parameter is not used. ${CMD} will ask for the password during
                            the installation process

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no uninstall
                            script there.  ${CMD} will not be able to determine which script to uninstall.
                            Use '--ignore' and indicate regulars expression to ignore useless files.
  
  --all                     If command installed on mutiple path and not indicate a target,
                            ${CMD} will try to delete all of them.


  The followint options indicate target path:
$(__usage_install_destination_info)


  The followint options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information
EOF
}


function yxct_usage_reinstall()
{

  function __usage_reinstall_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be install to'/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install
        the command to '/usr/local/bin' as default.
  
  Un-support destination options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be install to '/bin'
  --sbin                    The command will be install to '/sbin'
  --usr-bin                 The command will be install to '/usr/bin'
  --usr-local-bin           The command will be install to '/usr/local/bin'
  --usr-local-sbin          The command will be install to '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install the
        command to '/usr/local/bin' as default.
EOF
    fi
  }


cat <<EOF
  usage: ${CMD} reinstall <command> <optional>
  Reinstall a command

  usage: ${CMD} reinstall --help
  Show this help information

  The following options are availiable:
  --path <path>             1. Point to an install script or a folder that contains an install script.
                            2. Point to a command file, ${CMD} will try to install the command to system.
                            3. point to ${CMD} package with a 'yxct' extension or a folder that contains
                            the package (You can create a ${CMD} package with '${CMD} pack' command, or use
                            '${CMD} pack --help' to see more information).
  
  --cache [path]            Command will be install from cache directory. If the --cache parameter does not
                            provide a path. ${CMD} will try to find it from 'YXCT_CACHE_PATH' environment.
                            '--cache' has a lower priority than '--path'. If a valid '--path' parameter is
                            specified, the '--cache' parameter is ignored.
  
  --pass <pass>             When installing through a package, if the package requires a password,
                            you can provide it with '--pass' parameter. If the package requires a password,
                            but the '--pass' parameter is not used. ${CMD} will ask for the password during
                            the installation process

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no install
                            script there. ${CMD} will not be able to determine which script to install.
                            use '--ignore' and indicate regulars expression to ignore useless files.
  
  --force                   If an existing file on bin-path, remove it.


  The followint options indicate destination path:
$(__usage_reinstall_destination_info)
  

  The followint options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} install --help' show all help information
EOF
}


function yxct_usage_update()
{
cat <<EOF
  usage: ${CMD} update [--info-level xxx]
  Fetch the newest version of ${CMD} and all formulae from GitHub using git and perform any necessary migrations.

  The followint option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_config()
{
cat <<EOF
  usage: ${CMD} config get <--key domain.key> [--no-depend|--info-level]
  display a config item with specific key

  usage: ${CMD} config set <--key domain.key> <--val value> [--no-depend|--info-level]
  set a config item with specific key


  The followint option are availiable:
  --key           key of the key-value config item.
  --val           value of the key-value config item.

  --no-depend     ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level    Command output level. 
                  The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                  or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_pack()
{
cat <<EOF
  usage: ${CMD} pack <--repo-path path> <--pack-path path> [--pass xxx | --pass] [--force|--info-level]
  Create a ${CMD} installation pack from script.

  usage: ${CMD} unpack <--repo-path path> <--pack-path path> [--pass xxx | --pass] [--force|--info-level]
  Extra script from ${CMD} installation pack

  The followint option are availiable:
  --pass | --pass <xxx>   It's meand the installation package requires a password, and if no password
                          parameter is provided, ${CMD} will ask for a password during
                          the packing/unpacking process
  --force                 If an existing file or directory on target path, remove it.

  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_list()
{
cat <<EOF
  usage: ${CMD} list [--info-level | --no-depend]
  List all installed command tool.

  The followint option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


###########################################################
# Command
###########################################################

function cmd_install()
{
  local script_path=
  local bin_path=
  local pass=
  local -a ignore_reg_list=
  local additional=

  local use_cache=false
  local cache_path=

  local force=false
  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        script_path=$1
      ;;

      --cache )
        use_cache=true;
        if ! [[ "$2" =~ ^-.*$ ]]; then
          cache_path=$2
          shift
        fi
      ;;

      --force )
        force=true
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --pass )
        shift
        pass=$1
      ;;

      --bin )
        bin_path="${BIN_PATH}"
      ;;

      --sbin )
        bin_path="${SBIN_PATH}"
      ;;

      --usr-bin )
        bin_path="${USR_BIN_PATH}"
      ;;

      --usr-sbin )
        bin_path="${USR_SBIN_PATH}"
      ;;

      --usr-local-bin )
        bin_path="${USR_LOCAL_BIN_PATH}"
      ;;

      --usr-local-sbin )
        bin_path="${USR_LOCAL_SBIN_PATH}"
      ;;

      --custom-dest )
        shift
        bin_path=$1
      ;;

      --test )
        test=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_install
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi


    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi 

    # 如果未提供'script_path'
    if [ -z "${script_path}" ]; then

      # get a valid cache path
      # 如果 '--cache' 参数未提供 path
      if [ -z "${cache_path}" ]; then
        
        if [ -n "${YXCT_CACHE_PATH}" ]; then
          # 如果提供了环境变量， 从环境变量中读取 cache 路径
          # 环境变量中的 cache路径必须存在
          cache_path="${YXCT_CACHE_PATH}"
          if ! [ -e "${cache_path}" ]; then
            yxct_fatal "${cache_path} not exist"
          fi
        else
          # 如果没提供环境变量，使用默认cache路径.
          # 默认 cache 路径可能是空的或者未创建, 则说明未找到命令
          cache_path="$(yxct_get_default_cache_path)"
          if ! [ -d "${cache_path}" ]; then
            yxct_fatal "can not find command ${command} from cache"
          fi
        fi
      fi

      # 如果没指定 --cache 参数， 那么准备好 cache
      if ! ${use_cache}; then
        # update index
        if ! update_index_if_need; then
          yxct_fatal "failed to update index"
        fi

        if ! checkout_a_cache "${command}"; then
          yxct_fatal "failed to checkout '${command}'"
        fi
      fi

      # 在cache中搜索命令安装包，并更新script_path
      script_path=$(search_in_cache "${command}" "${cache_path}")
      if [ -z "${script_path}" ]; then
        yxct_fatal "can not find command ${command} from cache"
      fi
      
      # # 如果使用了 --cache 参数
      # if ${use_cache}; then
        
      #   # 在cache中搜索命令安装包，并更新script_path
      #   script_path=$(search_in_cache "${command}" "${cache_path}")
      #   if [ -z "${script_path}" ]; then
      #     yxct_fatal "can not find command ${command} from cache"
      #   fi

      # else
      #   if ! update_index_if_need; then
      #     yxct_fatal "failed to update index"
      #   fi

      #   checkout_a_cache "${command}"
      #   # exit 0
      #   yxct_fatal "Script path is empty. Use --help to show more information."
      # fi # end of (if ${use_cache}; then)
    fi


    if [ -z "${bin_path}" ]; then
      bin_path="${DEFAULT_BIN_PATH}"
    fi


    # extra package if need
    if [ -n "${script_path}" ]; then
      
      # 'script_path' 指向的可能是一个package, 也可能指向一个包含package的文件夹
      local single_file_path=
      if [ -f "${script_path}" ]; then
        single_file_path="${script_path}"
      elif [ -d "${script_path}" ]; then
        local single_file_name=$(file_name_if_single "${script_path}")
        if [ -n "${single_file_name}" ]; then
          single_file_path="${script_path%\/}/${single_file_name}"
        fi
      fi


      # 如果找到了一个文件
      if [ -n "${single_file_path}" ]; then

          # 这里通过扩展名，判断文件是否是一个 package
        local package_name=$(basename "${single_file_path}")
        if [[ "${package_name##*.}" == 'yxct' ]]; then

          local tmp_path=$(mktemp -d)
          if [ ! -d "${tmp_path}" ]; then
            yxct_fatal "Failed to create a temp directory"
          fi
          
          # 释放package里的内容
          local pass_params=
          if [ -n "${pass}" ]; then
            pass_params="--pass ${pass}"
          fi

          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
          if ! cmd_pack unpack --pack-path "${single_file_path}" --repo-path "${tmp_path}" --force ${pass_params}; then
            yxct_fatal "failed to unpack pakcage:${package}"
          fi
          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

          # 新的script_path路径
          script_path="${tmp_path%\/}/${package_name%.*}"
        fi

      fi # end of (if [ -n "${single_file_path}" ]; then)

    fi # end of (if [ -n "${script_path}" ]; then)



    local params=''
    # --command
    if [ -n "${command}" ]; then
      params="${params} --command ${command}"
    fi
    
    # --bin-path
    if [ -n "${bin_path}" ]; then
      params="${params} --bin-path ${bin_path}"
    fi


    local cmd_cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)
    if ! [ -d "${cmd_cellar_path}" ]; then

      if [ -f "${script_path}" ]; then
      # 如果脚本路径是一个文件

        local script_file_name=$(basename ${script_path})
        if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
        # 如果文件是一个安装脚本, 直接调用脚本
          if run_setup_script install --path "${script_path}" ${params} ${additional}; then
            setup_cellar install "${command}" --install-script "${script_path}"
          else
            yxct_fatal "failed on install ${command}"
          fi
        else
        # 如果文件是不是一个安装脚本

          local force_params=''
          if ${force}; then
            force_params='--force'
          fi

          if [[ "${script_file_name}" == "${command}" ]] ||  [[ "${script_file_name%.*}" == "${command}" ]]; then
          # 如果'--path'指向的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
            if install_file --file "${script_path}" "${force_params}" ${params}; then
              setup_cellar install "${command}" --install-file "${script_path}" 
            else
              yxct_fatal "failed on install ${command}"
            fi
          else
          # '--path'指向文件名与'command'不同的情况下，验证是否指定了 ‘--strict’ 参数. 没指定则强制安装文件, 并改名为command.
            if install_file --file "${script_path}" "${force_params}" ${params}; then
              setup_cellar install "${command}" --install-file "${script_path}" 
            else
              yxct_fatal "failed on install ${command}"
            fi
          fi

        fi
      elif [ -d "${script_path}" ]; then
        # 如果脚本路径是一个目录
        local install_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
        if [ -n "${install_script_filename}" ]; then
          # 如果目录中找到安装脚本, 直接掉用那个安装脚本
          local script_path="${script_path%\/}/${install_script_filename}"
          if run_setup_script install --path "${script_path}" ${params} ${additional}; then
            setup_cellar install "${command}" --install-script "${script_path}"
          else
            yxct_fatal "failed on install ${command}"
          fi
        else

          local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
          if [ -n "${singl_app_name}" ]; then
          # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，只剩下一个文件

            local force_params=''
            if ${force}; then
              force_params='--force'
            fi
            
            local app_path="${script_path%\/}/${singl_app_name}"
            if [[ "${singl_app_name}" == "${command}" ]] ||  [[ "${singl_app_name%.*}" == "${command}" ]]; then
            # 如果这唯一的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
              if install_file --file "${app_path}" "${force_params}" ${params}; then
                setup_cellar install "${command}" --install-file "${script_path}"
              else
                yxct_fatal "failed on install ${command}"
              fi
            else
            # 这唯一的文件与'command'名字不同的情况下，没指定则强制安装文件, 并改名为command.
              if install_file --file "${app_path}" "${force_params}" ${params}; then
                setup_cellar install "${command}" --install-file "${script_path}"
              else
                yxct_fatal "failed on install ${command}"
              fi
            fi
          else
            # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，还有多个文件，则不知道如何安装, 直接报错
            yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to install the command."
          fi

        fi
      else
      # 既不是文件，也不是目录，无效script_path
        yxct_fatal "Invalid script path:${script_path}"
      fi

    else # end of (if ! [ -d "${cmd_cellar_path}" ]; then)

      yxct_msg "${command} is already installed."
      exit 1

    fi # end of (if ! [ -d "${cmd_cellar_path}" ]; then)

  fi

  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    yxct_msg "${command} install success."
  fi
}


function cmd_uninstall()
{
  local script_path=
  local bin_path=
  local pass=
  local -a ignore_reg_list=
  local additional=

  local force=false
  local all=false
  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        script_path=$1
      ;;

      --all )
        all=true
      ;;

      --pass )
        shift
        pass=$1
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --bin )
        bin_path="${BIN_PATH}"
      ;;

      --sbin )
        bin_path="${SBIN_PATH}"
      ;;

      --usr-bin )
        bin_path="${USR_BIN_PATH}"
      ;;

      --usr-sbin )
        bin_path="${USR_SBIN_PATH}"
      ;;

      --usr-local-bin )
        bin_path="${USR_LOCAL_BIN_PATH}"
      ;;

      --usr-local-sbin )
        bin_path="${USR_LOCAL_SBIN_PATH}"
      ;;

      --custom-dest )
        shift
        bin_path=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --test )
        test=true;
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_uninstall
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi


    # extra package if need
    if [ -n "${script_path}" ]; then

      # 'script_path' 指向的可能是一个package, 也可能指向一个包含package的文件夹
      local single_file_path=
      if [ -f "${script_path}" ]; then
        single_file_path="${script_path}"
      elif [ -d "${script_path}" ]; then
        local single_file_name=$(file_name_if_single "${script_path}")
        if [ -n "${single_file_name}" ]; then
          single_file_path="${single_file_path%\/}/${single_file_name}"
        fi
      fi


      # 如果找到了一个文件
      if [ -n "${single_file_path}" ]; then

        # 这里通过扩展名，判断文件是否是一个 package
        local package_name=$(basename "${single_file_path}")
        if [[ "${package_name##*.}" == 'yxct' ]]; then

          local tmp_path=$(mktemp -d)
          if [ ! -d "${tmp_path}" ]; then
            yxct_fatal "Failed to create a temp directory"
          fi
          

          # 释放package里的内容
          local pass_params=
          if [ -n "${pass}" ]; then
            pass_params="--pass ${pass}"
          fi

          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
          if ! cmd_pack unpack --pack-path "${single_file_path}" --repo-path "${tmp_path}" --force ${pass_params}; then
            yxct_fatal "failed to unpack pakcage:${package}"
          fi
          YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

          # 新的script_path路径
          script_path="${tmp_path%\/}/${package_name%.*}"
        fi

      fi # end of (if [ -n "${single_file_path}" ]; then)

    fi # end of (if [ -n "${script_path}" ]; then)


    local params=''
    if [ -n "${command}" ]; then
      params="${params} --command ${command}"
    fi


    # try fix setup script path from cellar if it not exist
    local setup_script_path="${script_path}"
    if [ -z "${setup_script_path}" ]; then
      setup_script_path=$(yxct_get_cellar_item "${command}" --setup-script)
    fi


    local result=
    if [ -n "${setup_script_path}" ]; then
      # 如果提供了脚本路径, 或从cellar找到了当时安装时的setup脚本

      if [ -n "${bin_path}" ]; then
        params="${params} --bin-path ${bin_path}"
      fi
      if ${all}; then
        params="${params} --all"
      fi


      uninstall_by_script_path --path "${setup_script_path}" ${params} --ignore ${ignore_reg_list[@]} ${additional}
      result=$?

    elif [ -n "${bin_path}" ]; then
      # 如果找不到脚本路径， 但bin_path不为空

      uninstall_by_bin_path --path "${bin_path}" ${params}
      result=$?
    elif [ -n "${command}" ]; then
      # 如果没提供脚本路径和bin_path, 但提供了command

      if ${all}; then
        params="${params} --all"
      fi

      local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
      if [ -n "${cellar_hash}" ]; then
        params="${params} --hash ${cellar_hash}"
      fi

      remove_command ${params}
      result=$?
    else
      yxct_fatal "Invalid parameters, use --help to show more information."
    fi
  fi


  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    if [[ "${result}" == 0 ]]; then
      yxct_msg "${command} uninstall success."
    else
      yxct_fatal "failed uninstall ${command}."
    fi
  fi

}

function cmd_update()
{
  local repo="${DIR}"
  local info_level=
  local no_depend=false
  local show_help=false

  while [ $# -gt 0 ]; do
    case $1 in
      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_update
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    # Force root
    if [ "$(id -u)" -ne 0 ]; then
      yxct_fatal "'${CMD} update' command should run with root"
    fi


    yxct_git_repo update --repo "${repo}"
    local result=$?
    if [[ "${result}" == '0' ]]; then
      yxct_msg "update success"
    elif [[ "${result}" == '11' ]]; then
      yxct_msg "${CMD} is already the latest version"
    else
      yxct_fatal "update failed"
    fi

  fi

}

function cmd_reinstall()
{
  local test=false
  local info_level=
  local additional=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi 


  while [ $# -gt 0 ]; do

    case $1 in

      --test )
        test=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_reinstall
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi

    local params=
    if ${test}; then
      params="${params} --test"
    fi

    if ${no_depend}; then
      params="${params} --no-depend"
    fi

    if [ -n "${info_level}" ]; then
      params="${params} --info-level ${info_level}"
    fi


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    if ! cmd_uninstall "${command}" ${params} ; then
      yxct_fatal "failed on remove old ${command}"
    fi
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    cmd_install "${command}" ${params} ${additional};
    local result=$?
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
      if [[ "${result}" == 0 ]]; then
        yxct_msg "${command} reinstall success."
      fi
    fi

  fi

}

#usage
# yxct_config set --key domain.name --val val
# usage
# yxct_config get --key domain.name
function cmd_config()
{
  local domain=
  local key=
  local val=
  local option=

  local info_level=
  local no_depend=false
  local show_help=false

  if ! [[ "$1" =~ ^-.*$ ]]; then
    if yxct_strcontains "$1" "get" --ignorecase; then
      option='GET'
    elif yxct_strcontains "$1" "set" --ignorecase; then
      option='SET'
    else
      option=$1
    fi

    shift
  else
    # get is default option
    option='GET'
  fi


  local cursor=
  while [ $# -gt 0 ]; do
    case $1 in
      --key )
        cursor=$1
      ;;

      --val )
        cursor=$1
      ;; 

      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--key' ]]; then
            key=$(echo "${key} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--val' ]]; then
            val=$(echo "${val} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yxct_fatal "invalid name of ${cursor} $1"
          fi
        else
          yx_fatal "invalid optional ${1}"
        fi
      ;;

    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_config
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    if [ -z "${key}" ]; then
      yxct_fatal "key is empty."
    fi


    # get domain section from key string.
    domain="${key%%\.*}"
    if [[ "${domain}" == "${key}" ]]; then
      yxct_fatal "invalid key format:${key}, no domain found"
    fi

    # get real key which remove 'domain' section from --key params
    key="${key#[^\.]*\.}"



    # get config directory
    local config_dir=$(yxct_get_cmd_item --config)
    if [ -z "${config_dir}" ]; then
      yxct_fatal "failed to get config dir"
    fi

    # read or write the config file
    local file="${config_dir}/${domain}"
    if [[ "${option}" == 'GET' ]]; then
      if [ -f "${file}" ]; then
        yxct_config_read --file "${file}" --key "${key}"
      fi
    elif [[ "${option}" == 'SET' ]]; then
      if ! [ -d "${config_dir}" ]; then
        yxct_verbcmd "${MKDIR} -p ${config_dir}"
        if ! [ -d "${config_dir}" ]; then
          yxct_verbcmd "failed to make dir:${config_dir}"
        fi
      fi

      yxct_config_write --file "${file}" --key "${key}" --val "${val}"
    fi


  fi # end of (if ${show_help}; then)

}

function cmd_pack()
{
  local repo_path=
  local pack_path=
  local pass=
  # local command=
  local encrypt=false
  local force=false

  local info_level=
  local no_depend=false
  local show_help=false
  local option=

  if ! [[ $1 =~ ^-.*$ ]]; then
    if yxct_strcontains "${1}" "pack" --ignorecase; then
      option='PACK'
    elif yxct_strcontains "${1}" "unpack" --ignorecase; then
      option='UNPACK'
    else
      option=$1
    fi
    shift
  fi

  # if ! [[ $1 =~ ^-.*$ ]]; then
  #   command=$1
  #   shift
  # fi

  local cursor=
  while [ $# -gt 0 ]; do

    case $1 in

      --repo-path )
        cursor=$1
      ;;

      --pack-path )
        cursor=$1
      ;;

      --pass )
        encrypt=true
        cursor=$1
      ;;

      --force )
        cursor=
        force=true
      ;;

      --info-level )
        shift
        cursor=
        info_level=$1
      ;;

      --no-depend )
        cursor=
        no_depend=true
      ;;

      --help | h )
        cursor=
        show_help=true
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--repo-path' ]]; then
            repo_path=$(echo "${repo_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--pack-path' ]]; then
            pack_path=$(echo "${pack_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--pass' ]]; then
            pass=$(echo "${pass} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yx_fatal "Invalid name of ${cursor} $1"
          fi
        else
          yx_fatal "Invalid optional ${1}"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_pack
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    if [[ "${option}" == 'PACK' ]]; then
      

      if [ -z "${repo_path}" ]; then
        yxct_fatal "repo path is empty. Use '${CMD} pack --help' to show help information"
      fi

      if [ -z "${pack_path}" ]; then
        yxct_fatal "package path is empty"
      fi

      # Create a temp directory
      local tmp_path=$(mktemp -d)
      if [ ! -d "${tmp_path}" ]; then
        yxct_fatal "Failed to create a temp directory"
      fi

      local command=$(basename "${repo_path}")

      # Compress the package
      local tar_file="${tmp_path%\/}/tar"
      pushd $(dirname "${repo_path}") > /dev/null || yxct_fatal "failed to pushd ${repo_path}"
      yxct_verbcmd "${TAR} --create --file ${tar_file} ${command}"
      popd > /dev/null || yxct_fatal "failed to popd from ${repo_path}"


      # encrypt if need
      local target_file=
      local pack_file=
      if ${encrypt}; then

        local encrypt_file="${tmp_path%\/}/encrypted"
        if [ -z "${pass}" ]; then
          if [ -z "${pkg_pass}" ]; then
            local pass1=
            local pass2=
            echo -n "Enter encryption password:"
            read -s pass1
            echo ""

            echo -n "Verifying encryption password:"
            read -s pass2
            echo ""

            if [[ "${pass1}" == "${pass2}" ]]; then
              pass="${pass1}"
            else
              echo_fatal "Password not matched"
            fi
          fi
        fi

        if ! yxct_verbcmd "${OPENSSL} enc -e -aes256 -iter 100 -pbkdf2 -in ${tar_file} -out ${encrypt_file} --pass pass:${pass}"; then
          yxct_fatal "Failed to encrypt package"
        fi

        target_file="${encrypt_file}"
        # pack_file="${pack_path}/${command}.yxct"
      
      else
        target_file="${tar_file}"
        # pack_file="${pack_path}/${command}.yxct"
      fi

      # Make pack file's dir if not exist
      if ! [ -d "${pack_path}" ]; then
        yxct_err "${pack_path} not exist, try create one"
        yxct_verbcmd "${MKDIR} -p ${pack_path}" > /dev/null
        if ! [ -d "${pack_path}" ]; then
          yxct_fatal "failed to mkdir ${pack_path}"
        fi
      fi

      # copy file
      local force_params=''
      local pack_file="${pack_path}/${command}.yxct"
      if [ -f "${pack_file}" ]; then
        if "${force}"; then
          force_params="-f"
        else
          yxct_fatal "file ${pack_file} already exist, use '--force' to replace it or '${CMD} pack --help' to show help information"
        fi
      fi

      if ! yxct_verbcmd "${CP} ${force_params} ${target_file} ${pack_file}"; then
        yxct_fatal "failed to copy file to ${pack_file}"
      else
        if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
          yxct_msg "pack success"
        fi
      fi

     
    elif [[ "${option}" == 'UNPACK' ]]; then
      if [ -z "${repo_path}" ]; then
        yxct_fatal "repo path is empty. Use '${CMD} pack --help' to show help information"
      fi

      if [ -z "${pack_path}" ]; then
        yxct_fatal "package path is empty"
      elif ! [ -f "${pack_path}" ]; then
        yxct_fatal "package path ${pack_path} not exist"
      fi


      # Create a temp directory
      local tmp_path=$(mktemp -d)
      if [ ! -d "${tmp_path}" ]; then
        yxct_fatal "Failed to create a temp directory"
      fi




      # decrypt if need
      # target_path & repo_path
      local target_path=
      local filename=$(basename "${pack_path}")
      if ! "${TAR}" -tf "${pack_path}" &> /dev/null; then
        local decrpyt_file="${tmp_path%\/}/decrypt"

        local pass_param=''
        if [ -n "${pass}" ]; then
          pass_param="--pass pass:${pass}"
        fi
        if ! "${OPENSSL}" enc -d -aes256 -iter 100 -pbkdf2 -in "${pack_path}" --out "${decrpyt_file}" ${pass_param}; then
          yxct_fatal "failed to dencrypt file:${pack_path}"
        fi

        target_path="${decrpyt_file}"
      else
        target_path="${pack_path}"
      fi


      # extract package
      local extra_path="${tmp_path%\/}/extra"
      if ! "${MKDIR}" -p "${extra_path}"; then
        yxct_fatal "failed to make dir:${target_path}"
      fi
      if ! yxct_verbcmd "/usr/bin/tar --extract --file=${target_path} --directory=${extra_path}"; then
        yxct_fatal "failed to extract package"
      fi
      target_path="${extra_path}"


      # search extract result
      # must only one file or directory in package.
      local repo_name=
      local finded=false
      for file in "${target_path%\/}"/*; do
        if ${finded}; then
          yxct_fatal "mutiple files or directory in package"
        fi

        finded=true
        repo_name=$(basename "${file}")
      done

      if [ -z "${repo_name}" ]; then
        yxct_fatal "failed to find file or directory in package"
      fi

      target_path="${target_path%\/}"/${repo_name}



      # Make repo file's dir if not exist
      if ! [ -d "${repo_path}" ]; then
        yxct_err "${repo_path} not exist, try create one"
        yxct_verbcmd "${MKDIR} -p ${repo_path}" > /dev/null
        if ! [ -d "${repo_path}" ]; then
          echo_fatal "failed to mkdir ${repo_path}"
        fi
      fi

      # copy file
      local params=''
      if [ -f "${repo_path}" ]; then
        if "${force}"; then
          params="-f"
        else
          yxct_fatal "file ${repo_path} already exist, use '--force' to replace it or '${CMD} unpack --help' to show help information"
        fi
      fi

      if [ -d "${target_path}" ]; then
        params="${params} -R"
      fi

      if ! yxct_verbcmd "${CP} ${params} ${target_path%\/}/${repo_name} ${repo_path}"; then
        yxct_fatal "failed to copy file to ${pack_file}"
      else
        if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
          yxct_msg "unpack success"
        fi
      fi


    fi # end of(if [[ "${option}" == 'PACK' ]]; then)


  fi # end of (if ${show_help}; then)
}


function cmd_list()
{
  local info_level=
  local no_depend=false
  local show_help=false

  while [ $# -gt 0 ]; do

    case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_list
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    local cmd_cellar_path=$(yxct_get_cellar_item "${CMD}" --cellar-path)
    if [ -z "${cmd_cellar_path}" ]; then
      yxct_fatal "failed to get command cellar path"
    fi

    local cellar_path=$(dirname "${cmd_cellar_path}")
    if [ -z "${cellar_path}" ]; then
      yxct_fatal "failed to get cellar path"
    fi

    for item in "${cellar_path%\/}"/*; do
      basename "${item}"
    done

  fi

}


####################################################################################################
# Entry
####################################################################################################


# 不要限制'PATH', 会引起`which`命令无法查找
# PATH=/sbin:/bin:/usr/bin

# 设置默认日志级别。
if [ -n "${YXLOGGER_DEFAULT_LEVEL}" ]; then
  # 尝试继承当前环境中YXLib的日志级别。
  yxct_set_info_level "${YXLOGGER_DEFAULT_LEVEL}"
else
  # 使用 yxct 级别 设置日志级别
  # 注意: 这里扔需要设置一次
  # 因为 yxct_set_inf_level 可能需要将默认参数透传给 YXLogger
  yxct_set_info_level "${YXCT_DEFAULT_LEVEL}"
fi

# 如果syslog的tag没被设置(没有上层脚本), 则将其设置为${CMD}
if [ -n "${YXLOGGER_SYSLOG_TAG}" ]; then
  YXLOGGER_SYSLOG_TAG="${CMD}"
fi

if [[ $(yxct_os_type) == 'osx' ]]; then
  # on osx, '/usr/local/sbin' is not a standard bin path
  BIN_PATH="${USR_LOCAL_BIN_PATH}"
  SBIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_BIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_SBIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_LOCAL_SBIN_PATH="${USR_LOCAL_BIN_PATH}"

  CP=/bin/cp
  RM=/bin/rm
  CHMOD=/bin/chmod
  BASH=/bin/bash
  ENV=/usr/bin/env
  MKDIR=/bin/mkdir
  LN=/bin/ln
  TAR=/usr/bin/tar
  OPENSSL=/usr/local/bin/openssl
else
  CP=/usr/bin/cp
  RM=/usr/bin/rm
  CHMOD=/usr/bin/chmod
  BASH=/bin/bash
  ENV=/usr/bin/env
  MKDIR=/usr/bin/mkdir
  LN=/usr/bin/ln
  TAR=/usr/bin/tar
  OPENSSL=/usr/bin/openssl
fi



sub_cmd=$1
shift
if [[ -z ${sub_cmd} ]]; then
  yxct_fatal "Param error. use '${CMD} --help' to show document"
fi




if [ -z "${YXCT_NESTED_FLAG}" ]; then
  export YXCT_NESTED_FLAG=1
else
  YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
fi


if [[ "${sub_cmd}" == 'install' ]]; then
  cmd_install $@;
elif [[ "${sub_cmd}" == 'uninstall' ]]; then
  cmd_uninstall $@
elif [[ "${sub_cmd}" == 'reinstall' ]]; then
  cmd_reinstall $@
elif [[ "${sub_cmd}" == 'update' ]]; then
  cmd_update $@
elif [[ "${sub_cmd}" == 'list' ]]; then
  cmd_list $@
elif [[ "${sub_cmd}" == 'pack' ]]; then
  cmd_pack pack $@
elif [[ "${sub_cmd}" == 'unpack' ]]; then
  cmd_pack unpack $@
elif [[ "${sub_cmd}" == 'set' ]]; then
  cmd_config set $@
elif [[ "${sub_cmd}" == 'get' ]]; then
  cmd_config get $@
elif [[ "${sub_cmd}" == '-' ]]; then
  : # nested call. do nothing ...
elif [[ "${sub_cmd}" == '--help' ]] || [[ "${sub_cmd}" == '-h' ]]; then
  yxct_usage
else
  yxct_fatal "Unknown sub command:'${sub_cmd}'. Use ${CMD} --help tho show help information."
fi


YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))