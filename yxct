#!/usr/bin/env bash

if [ -z "${CMD}" ]; then
  CMD=$(basename $0)
fi


if [ -z "${SOURCE}" ]; then
  SOURCE="$0"
  DIR=
  while [ -h "$SOURCE"  ]; do
    DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd  )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /*  ]] && SOURCE="$DIR/$SOURCE"
  done
  DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd  )"
fi


if [ -z "${YXCT_USEYXLIB}" ]; then
  if which yxlibinit > /dev/null; then
    source yxlibinit -
    source yxlogger
    export YXCT_USEYXLIB=true
  else
    export YXCT_USEYXLIB=false
  fi
elif "${YXCT_USEYXLIB}"; then
  source yxlogger
fi



BIN_PATH='/bin'
SBIN_PATH='/sbin'
USR_BIN_PATH='/usr/bin'
USR_SBIN_PATH='/usr/sbin'
USR_LOCAL_BIN_PATH='/usr/local/bin'
USR_LOCAL_SBIN_PATH='/usr/local/sbin'
DEFAULT_BIN_PATH="${USR_LOCAL_BIN_PATH}"





#Display comand only, not run
if [ -z "${TEST_ONLY}" ]; then
  TEST_ONLY=false
fi

##############################################################
# !! 因为yxct不能用YXLib, 下面这些变量必须与yxlogger 中定义的相同
##############################################################
readonly YXCT_LEVEL_SILENT=0
readonly YXCT_LEVEL_FATAL=1
readonly YXCT_LEVEL_ERROR=4
readonly YXCT_LEVEL_WARN=5
readonly YXCT_LEVEL_INFO=8
readonly YXCT_LEVEL_VERBOSE=9
readonly YXCT_LEVEL_DEBUG=11
readonly YXCT_LEVEL_TRACE=12
readonly YXCT_LEVEL_ALL=99

if [ -z "${YXCT_DEFAULT_LEVEL}" ]; then
  YXCT_DEFAULT_LEVEL="${YXCT_LEVEL_INFO}"
fi


###########################################################
# Ignore file list in script folder
###########################################################

IGNORE_LIST=(
  # git
  "\.gitignore"
  "\.git"
  "\.gitkeep"
  
  ################
  #vim
  # # vim->swap
  "[._]*\.s[a-v][a-z]"
  "[._]*.sw[a-p]"
  "[._]s[a-rt-v][a-z]"
  "[._]ss[a-gi-z]"
  "[._]sw[a-p]"
  # # vim->session
  "Session"
  "Sessionx"
  # # vim->Temporary
  "\.netrwhist"
  "\*~"
  # # vim->Auto-generated tag files
  "tags"
  # # vim->Persistent undo
  "[._]*.un~"
  
  ################
  #vscode
  "\.vscode"
  # # vscode->Local History for Visual Studio Code
  "\.history"
  # # vscode->Built Visual Studio Code Extensions
  ".*\.vsix"
  # # vscode->VisualStudioCode Patch
  "\.history"
  "\.ionide"
  
  # custom
  "README(\.md)?"
  "test(\.sh)?"
  "sample(\.sh)?"
)


###########################################################
# YXLib
###########################################################
# 第一个参数，必须是script path.
function yxct_run_script()
{
  # get script file path from command
  local script_path=$(echo $@ | awk '{print $1}')
  
  if [ -n "${script_path}" ]; then
    
    # get shebang line from command
    local shebang=$(head -n 1 "${script_path}")
    if echo ${shebang} | grep -Eq "^#!.*"; then
      # if shebang exist, call commmand directly
      yxct_verbcmd "eval $@"
    else
      # try get file extension name
      local file_ext=${script_path##*.}

      # call command by extension name
      if [ -n "${file_ext}" ]; then
        if yxct_strcontains "${file_ext}" "sh" --ignorecase; then
          yxct_verbcmd "eval ${BASH} $@"
        elif yxct_strcontains "${file_ext}" "py" --ignorecase; then
          yxct_verbcmd "eval ${ENV} python3 $@"
        else
          yxct_verbcmd "eval $@"
        fi
      fi

    fi # end of (echo ${title} | grep -Eq "^#!.*"; then)
  fi # end of (if [ -n "${script_path}" ]; then)
}


function yxct_os_type()
{
  
  local release=''
  
  if [ -n "${OSTYPE}" ]; then
    if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
      release="linux"
    elif [[ "${OSTYPE}" == "bsd"* ]]; then 
      release="bsd"
    elif [[ "${OSTYPE}" == "freebsd"* ]]; then 
      release="freebsd"
    elif [[ "${OSTYPE}" == "darwin"* ]]; then 
      release="osx"
    elif [[ "${OSTYPE}" == "solaris"* ]]; then 
      release="solaris"
    elif [[ "${OSTYPE}" == "cygwin" ]]; then 
      # POSIX compatibility layer and Linux environment emulation for Windows 
      release="cygwin"
    elif [[ "${OSTYPE}" == "msys" ]]; then 
      # Lightweight shell and GNU utilities compiled for Windows (part of MinGW) 
      release="msys"
    elif [[ "${OSTYPE}" == "win32" ]]; then 
      # I'm not sure this can happen. 
      release="windows"
    else 
      release="unknown"
    fi
  else
    
    # $OSTAYPE not recognized by the older shells (such as Bourne shell).
    # Use `uname` instead
    
    case $(uname | tr '[:upper:]' '[:lower:]') in
      linux*)
        release='linux'
      ;;
      freebsd*)
        release='freebsd'
      ;;
      darwin*)
        release="osx"
      ;;
      SunOS*)
        release="solaris"
      ;;
      msys*)
        release="msys"
      ;;
      windows*)
        release="windows"
      ;;
      *)
        release="unknown"
      ;;
    esac
  fi
  

  echo "${release}"
}

function yxct_verbose()
{
  if ${YXCT_USEYXLIB}; then
    yx_verb $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_VERBOSE}" )); then
      return
    fi

    (>&1 echo "$1")

  fi


}

function yxct_msg()
{
  if ${YXCT_USEYXLIB}; then
    yx_msg $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_INFO}" )); then
      return
    fi

    echo $*

  fi


}

function yxct_fatal()
{
  YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))

  if ${YXCT_USEYXLIB}; then
    yx_fatal $@
  else

    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_FATAL}" )); then
      return
    fi

    local red=$(tput setaf 1);
    local reset=$(tput sgr0);
    
    (>&2 echo "${red}Fatal:${1}${reset}");
    exit 1;

  fi


}


function yxct_verbcmd()
{
  if ${YXCT_USEYXLIB}; then
    if ${TEST_ONLY}; then
      yx_verbcmd --test $@
    else
      yx_verbcmd $@
    fi
  else
    if ${TEST_ONLY}; then
      yxct_verbose "Test-only:$*"
      return
    else
      yxct_verbose "$*"
    fi

    $@
  fi


}

function yxct_err()
{
  if ${YXCT_USEYXLIB}; then
    yx_err $@
  else
    if (( "${YXCT_DEFAULT_LEVEL}" < "${YXCT_LEVEL_ERROR}" )); then
      return
    fi

    local magenta=$(tput setaf 5);
    local reset=$(tput sgr0);

    (>&2 echo "${magenta}${1}${reset}")
  fi

}

function yxct_str_checkfmt()
{
  local reg=$1
  local str=$2
  
  if [[ -z ${str} ]]; then
    str=''
  fi
  
  if [[ -z ${reg} ]]; then
    reg='^\s*[^\s]+\s*$'
  fi
  
  if ! [[ ${str} =~ ${reg} ]] ; then
    return 1
  fi
  
  return 0
}

function yxct_strcontains()
{
  local str="$1"
  local arr_str="$2"
  local ignorecase=false
  shift 
  shift 
  
  while [ $# -gt 0 ]; do
    case $1 in
      
      --ignorecase )
        ignorecase=true
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done

  
  if ${ignorecase}; then
    if [[ $(yxct_shell_type) == 'bash' ]]; then
      for e in $(echo "${arr_str}"); do
        [[ "${e^^}" == "${str^^}" ]] && return 0
      done
    else
      for e in $(echo "${arr_str}"); do
        [[ "${e:u}" == "${str:u}" ]] && return 0
      done
    fi
  else
    for e in $(echo "${arr_str}"); do
      echo "compare between ${e} and ${str}"
      [[ "${e}" == "${str}" ]] && return 0
    done
  fi
  
  return 1
}

function yxct_shell_type()
{
  local shell_type=
  if [ -n "${ZSH_VERSION}" ]; then
    shell_type='zsh'
  elif [ -n "${BASH_VERSION}" ]; then
    shell_type='bash'
  else
    :
  fi

  echo "${shell_type}"
}

###########################################################
# Utility
###########################################################

function yxct_get_library_path()
{
  local lib_path=
  if [[ $(yxct_os_type) == 'osx' ]]; then
    lib_path="/usr/local/yuxi"
  else
    lib_path="/usr/yuxi"
  fi

  echo "${lib_path}"
}

function yxct_get_cellar_item()
{
  local command=
  if ! [[ $1 =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "empty command on cellar item"
  fi


  local type=
  while [ $# -gt 0 ]; do
    case $1 in
      
      --setup-script )
       type=$1
      ;;

      --command-hash )
       type=$1
      ;;

      --cellar-path )
       type=$1
      ;;
      
      *)
        echo "Invalid optional ${1}"
      ;;
    esac
    shift
  done


  # get cellar_path
  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi


  local result=0
  local cellar_path="${library_path%\/}/${CMD}/cellar/${command}"
  if [[ "${type}" == '--setup-script' ]]; then
    if [ -f "${cellar_path}/.${CMD}.setup.sh" ]; then
      echo "${cellar_path}/.${CMD}.setup.sh"
    elif [ -f "${cellar_path}/.${CMD}.setup.py" ]; then
      echo "${cellar_path}/.${CMD}.setup.py"
    elif [ -f "${cellar_path}/.${CMD}.setup.rb" ]; then
      echo "${cellar_path}/.${CMD}.setup.rb"
    else
      result=1
    fi
  elif [[ "${type}" == '--command-hash' ]]; then
    if [ -f "${cellar_path}/hash" ]; then
      grep -o "[^ ]\+\( \+[^ ]\+\)*" "${cellar_path}/hash"
      result=$?
    else
      result=1
    fi
  elif [[ "${type}" == '--cellar-path' ]]; then
    echo "${cellar_path}"
  else
    echo "${cellar_path}"
  fi

  return ${result}
}


function setup_cellar()
{
  local command=

  local install_script=
  local install_file=

  local option=
  if yxct_strcontains "$1" "install" --ignorecase; then
    option='INSTALL'
    shift
  elif yxct_strcontains "$1" "uninstall" --ignorecase; then
    option='UNINSTALL'
    shift
  else
    yxct_fatal "unknown option in setup cellar"
  fi

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  else
    yxct_fatal "command is empty"
  fi


  while [ $# -gt 0 ]; do
    case $1 in

      --install-file )
        shift
        install_file=$1
      ;; 

      --install-script )
        shift
        install_script=$1
      ;; 

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done


  if [ -z "${command}" ]; then
    yxct_fatal "command is empty"
  fi


  local cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)
  if [ -z "${cellar_path}" ]; then
    yxct_fatal "failed to get cellar path of command:${command}"
  fi


  if [[ "${option}" == 'INSTALL' ]]; then

    # create cellar dir
    if [ -d "${cellar_path}" ]; then
      yxct_err "cell path already exist, try remove it:${cellar_path}"
      if ! yxct_verbcmd "${RM} -rf ${cellar_path}"; then
        yxct_fatal "failed to remove old cellar dir:${cellar_path}"
      fi
    fi

    if ! yxct_verbcmd "${MKDIR} -p ${cellar_path}"; then
      yxct_fatal "failed to create dir:${cellar_path}"
    fi

    # copy file
    if [ -n "${install_script}" ]; then
      if [ -f "${install_script}" ]; then
        yxct_verbcmd "${CP} ${install_script} ${cellar_path}"
      else
        yxct_fatal "can not find a install script on setup cellar"
      fi
    fi

    if [ -n "${install_file}" ]; then
      if [ -f "${install_file}" ]; then
        local install_file_hash=$(shasum -a 256 "${install_file}" | awk '{print $1}')
        if [ -n "${install_file_hash}" ]; then
          echo "${install_file_hash}" > "${cellar_path}/hash"
        else
          yxct_fatal "failed to calculate the hash value on install file:${install_file}"
        fi
      else
        yxct_fatal "can not find a install file on setup cellar"
      fi
    fi

  elif [[ "${option}" == 'UNINSTALL' ]]; then
    if [ -d "${cellar_path}" ]; then
      yxct_verbcmd "${RM} -rf ${cellar_path}"
    fi
  else
    yxct_fatal "unknown option:${option}"
  fi

}

function yxct_set_info_level()
{
  local info_level=$1
  if [ -n "${info_level}" ]; then

    if ${YXCT_USEYXLIB}; then
      yx_logger set --output-level "${info_level}"
    fi

    if yxct_str_checkfmt '^([0-9])+$' "${info_level}"; then
      YXCT_DEFAULT_LEVEL="${info_level}"
      export YXLOGGER_DEFAULT_LEVEL="${info_level}"
    elif yxct_strcontains "${info_level}" 'silent' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_SILENT}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_SILENT}"
    elif yxct_strcontains "${info_level}" 'fatal fat' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_FATAL}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_FATAL}"
    elif yxct_strcontains "${info_level}" 'error err' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_ERROR}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_ERROR}"
    elif yxct_strcontains "${info_level}" 'warning warn' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_WARN}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_WARN}"
    elif yxct_strcontains "${info_level}" 'info msg' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_INFO}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_INFO}"
    elif yxct_strcontains "${info_level}" 'verbose verb' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_VERBOSE}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_VERBOSE}"
    elif yxct_strcontains "${info_level}" 'debug' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_DEBUG}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_DEBUG}"
    elif yxct_strcontains "${info_level}" 'trace' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_TRACE}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_TRACE}"
    elif yxct_strcontains "${info_level}" 'all' --ignorecase; then
      YXCT_DEFAULT_LEVEL=${YXCT_LEVEL_ALL}
      export YXLOGGER_DEFAULT_LEVEL="${YXCT_LEVEL_ALL}"
    else
      yxct_fatal "unknown info level :${info_level}"
    fi # end of (if yx_check_strfmt '^([0-9])+$' "${info_level}"; then)

  fi # end of 'if [ -n ${info_level} ]'
}


function is_in_reg_list()
{
  local name=$1
  shift
  local reg_list=($@)
  
  if [[ "${reg_list}" ]]; then
    for reg in "${reg_list[@]}"; do
      reg=$(echo "${reg}" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
      if echo "${name}" | grep -Eqi "${reg}"; then
        return 0
      fi
    done
  fi
  
  return 1
}


# 如果目录下只有一个文件，则返回
# 1. 会忽略 IGNORE_LIST 列表里正则对应的文件
# 2. 会忽略 --ignore 参数中正则列表对应的文件
# usage: file_name_if_single <目录>
# usage: file_name_if_single <目录> --ignore '正则1' '正则2' ....
function file_name_if_single()
{
  local script_path=$1
  local -a ignore_reg_list
  if [[ $2 == '--ignore' ]]; then
    shift # ignore $1
    shift # ignore --ignore
    ignore_reg_list=($@)
  fi

  
  local -a valid_files
  # local SAVEIFS=$IFS
  for file in "${script_path%\/}"/*; do

    if [[ ${file} =~ ^"${script_path%\/}"/*$ ]]; then
      continue
    fi

    local filename=$(basename  "${file}")    

    # 文件名在忽略列表里
    if is_in_reg_list "${filename}" ${ignore_reg_list[@]}; then
      continue
    fi

    if ! is_in_reg_list "${filename}" ${IGNORE_LIST[@]}; then
      valid_files=(${valid_files[@]} "${filename}")
    fi
    
  done
  # IFS=${SAVEIFS}
  
  if [[ "${#valid_files[@]}" == 1 ]]; then
    echo "${valid_files[@]}"
    return 0
  else
    return 1
  fi
}

function search_file_by_reg_list()
{
  local script_path=$1
  shift
  local reg_list=($@)

  # local SAVEIFS=$IFS


  # search regular files
  for file in "${script_path%\/}"/*; do

    if [[ ${file} =~ ^"${script_path%\/}"/*$ ]]; then
      continue
    fi

    local filename=$(basename "${file}")    
    if is_in_reg_list "${filename}" ${reg_list[@]}; then
      echo "${filename}"
      return 0
    fi
  done

  # search regular invisiable files 
  for file in "${script_path%\/}"/.*; do
    if [[ ${file} == ${script_path%/}/\* ]]; then
      continue
    fi

    local filename=$(basename "${file}")    
    if [[ ${filename} == '.' ]] || [[ ${filename} == '..' ]]; then
      continue
    fi

    if is_in_reg_list "${filename}" ${reg_list[@]}; then
      echo "${filename}"
      return 0
    fi
  done


  # IFS=${SAVEIFS}

  return 1
}


# function is_same_file()
# {
#   local file1=$1
#   local file2=$2

#   local file1_hash=
#   if [ -r "${file1}" ]; then
#     file1_hash=$(shasum -a 256 "${file1}")
#   fi

#   local file2_hash=
#   if [ -r ${file2} ]; then
#     file2_hash=$(shasum -a 256 "${file2}")
#   fi

#   if [[ -f "${file1}" ]] && [[ -f "${file2}" ]]; then
#     if [[ "${file1}" -eq "${file2}" ]]; then
#       return 0
#     fi
#   fi

#   return 1
# }


function check_file_hash()
{
  local file=$1
  local hash=$2

  if ! [ -r "${file}" ]; then
    yxct_fatal "Can not read the file:${file}"
  fi

  if [ -z "${hash}" ]; then
    yxct_fatal "hash is empty."
  fi

  local file_hash=$(shasum -a 256 "${file}" | awk '{print $1}')
  if [[ "${file_hash}" == "${hash}" ]]; then
    return 0
  else
    return 1
  fi
}

# 执行卸载脚本
function run_setup_script()
{
  local script_path=
  local bin_path=
  local additional=
  local all=false

  local option=$1
  if yxct_strcontains "${option}" 'install' --ignorecase; then
    option="install"
    shift
  elif yxct_strcontains "${option}" 'uninstall' --ignorecase; then
    option="uninstall"
    shift
  else
    yxct_fatal "option is empty."
  fi

  while [ $# -gt 0 ]; do
    case $1 in
      --path )
        shift
        script_path=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --all )
        all=true
      ;;


      *)
        additional="${additional} $1"
    esac
    shift
  done


  if ! [ -f "${script_path}" ]; then
    yxct_fatal "setup script not exist :${script_path}"
  fi
  
  if ! [ -x "${script_path}" ]; then
    yxct_err "Setup script does not have execution permissions. try add one."
    yxct_verbcmd "chmod +x ${script_path}"
  fi

  local library_path=$(yxct_get_library_path)
  if [ -z "${library_path}" ]; then
    yxct_fatal "failed to get library path"
  fi


  # 因为运行脚本，很可能使用了YXLib库，这里让运行脚本
  # 这里了设置yxlogger的环境变量
  local saved_yxlib_log_echo_level="${YXLOGGER_DEFAULT_LEVEL}"
  if [ -n "${YXCT_DEFAULT_LEVEL}" ]; then
    # 保存之前的环境变量
    export YXLOGGER_DEFAULT_LEVEL="${YXCT_DEFAULT_LEVEL}"
  fi


  local result
  if [ -n "${bin_path}" ]; then
  # 如果给了bin_path, 则按照 bin_path 给卸载脚本
    pushd $(dirname "${script_path}") > /dev/null
    yxct_run_script "${script_path} ${option} --bin-path ${bin_path} --lib-path ${library_path} ${additional}"
    result="$?"
    popd > /dev/null

    if [[ "${result}" != '0' ]]; then
      yxct_fatal "Failed to run setup script: ${script_path}"
    fi
  elif which "${command}" > /dev/null; then
  # else
  # 如果能找到 command, 根据command获得bin-path
    while true; do

      local finded_exec_path=$(which "${command}")
      if [ -z "${finded_exec_path}" ]; then
        break
      fi
      
      local bin_path=$(dirname "${finded_exec_path}")

      pushd $(dirname "${script_path}") > /dev/null
      yxct_run_script "${script_path} ${option} --bin-path ${bin_path} --lib-path ${library_path} ${additional}"
      result="$?"
      popd > /dev/null    

      if [[ "${result}" != '0' ]]; then
        yxct_fatal "Failed to run setup script: ${script_path}"
      fi

      if ! ${all}; then
        break
      fi
    done
  
  else
    # 如果没找到command, 完全不知道 --bin-path , 直接调用脚本
    pushd $(dirname "${script_path}") > /dev/null
    yxct_run_script "${script_path} ${option} --lib-path ${library_path} ${additional}"
    result="$?"
    popd > /dev/null

    if [[ "${result}" != '0' ]]; then
      yxct_fatal "Failed to run setup script: ${script_path}"
    fi
  fi


  # 这里要还原 YXLOGGER_DEFAULT_LEVEL
  # 使用和备份时相同的判断条件
  if [ -n "${YXCT_DEFAULT_LEVEL}" ]; then
    export YXLOGGER_DEFAULT_LEVEL="${saved_yxlib_log_echo_level}"
  fi



  # pushd $(dirname "${script_path}") > /dev/null
  # yxct_run_script "${script_path} ${option} ${additional}"
  # result="$?"
  # popd > /dev/null

  # if [[ "${result}" != '0' ]]; then
  #   yxct_fatal "Failed to run setup script: ${script_path}"
  # fi

  return ${result}
}

# 根据命令名直接卸载可执行文件
function remove_command()
{
  local all=false
  local command=
  local hash=

  while [ $# -gt 0 ]; do
    case $1 in
      --command )
        shift
        command=$1
      ;; 

      --hash )
        shift
        hash=$1
      ;; 

      --all )
        all=true
      ;; 
    esac
    shift
  done

  if [ -z "${command}" ]; then
    yxct_fatal "Command is empty !"
  fi


  # 提前额外验证一下， while循环里的验证不能抱错误警告
  if ! $(which "${command}" > /dev/null); then
    yxct_fatal "Can not find the command:${command}"
  fi

  while true; do
    local finded_exec_path=$(which "${command}")
    if [ -z "${finded_exec_path}" ]; then
      break
    fi

    if ! [ -w ${finded_exec_path} ]; then
     yxct_fatal "Have not permission to remove the file:${finded_exec_path}"
    fi

    if [ -n "${hash}" ]; then
      if ! check_file_hash "${finded_exec_path}" "${hash}"; then
        break
      fi
    fi

    # 强制删除命令
    yxct_verbcmd "${RM} -f ${finded_exec_path}"
    if [[ $? != '0' ]]; then
      yxct_fatal "Fail to uninstall '${command}'"
    fi

    if ! ${all}; then
      break
    fi

  done

  # remove setter
  setup_cellar uninstall "${command}"

  return 0
}

# 根据一个可执行文件，查找安装的命令，并卸载
# 可执行文件仅用于 hash验证
# 查找方式
# 1. which ${command}
# 2. bin_path/command 或 bin_path/$(basename command)
function remove_by_hash_file()
{
    local file_path=
    local bin_path=
    local command=
    local all=false

    while [ $# -gt 0 ]; do
      case $1 in
        --path )
          shift
          file_path=$1
        ;;

        --bin-path )
          shift
          bin_path=$1
        ;;

        --command )
          shift
          command=$1
        ;; 

        --all )
          all=true
        ;; 
      esac
      shift
    done

    if ! [ -f "${file_path}" ]; then
      yxct_fatal "File not exist :${file_path}"
    fi
    local file_hash=$(shasum -a 256 "${file_path}" | awk '{print $1}' )
    if [ -z "${file_hash}" ]; then
      yxct_fatal "Failed to calculate the hash value of the file:${file_path}"
    fi

    local filename=$(basename "${file_path}")
    # 如果提供了命令名，脚本名字和命令名必须相同
    if [ -n "${command}" ] && [ "${filename}" != "${command}" ]; then
      yxct_fatal "Filename name and command not matched."
    fi

    if [ -n "${bin_path}" ]; then

      local finded_exec_path=
      if [ -n "${command}" ]; then
        finded_exec_path="${bin_path}/${command}"
      else
        finded_exec_path="${bin_path}/${filename}"
      fi

      if ! [ -f ${finded_exec_path} ]; then
        yxct_fatal "Can not find a command at:${finded_exec_path}"
      fi

      # 要删除的文件必须和传入的文件相同
      if ! check_file_hash "${finded_exec_path}" "${file_hash}"; then
        yxct_fatal "Script and execute file not matched:(${execute_file_path})"
      fi

      # 强制删除命令
      yxct_verbcmd "${RM} -f ${execute_file_path}"
      if [[ $? != 0 ]]; then
        yxct_fatal "Fail to uninstall '${command}' in path:${bin_path}"
      fi
   else
     local params=''
     if "${all}"; then
       arams="${params} --all"
     fi

     remove_command --command "${filename}" --hash "${file_hash}" ${params}
   fi
}


function install_file()
{
  local file_path=
  local bin_path=
  local command=
  local force=false

  while [ $# -gt 0 ]; do
    case $1 in
      --file )
        shift
        file_path=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --command )
        shift
        command=$1
      ;;

      --force )
        force=true
      ;;
    esac
    shift
  done

  if [ -z "${file_path}" ]; then
    yxct_fatal "file path is empty."
  fi

  if ! [ -r "${file_path}" ]; then
    yxct_fatal "Can not read file:${file_path}"
  fi

  if [ -z ${bin_path} ]; then
    yxct_fatal "destination path is empty."
  fi

  if [ -z "${command}" ]; then
    command=$(basename "${file_path}")
  fi

  local dest_path="${bin_path}/${command}"

  # 在没有指定--force时，如果目标文件已存在，且和要考呗的文件不同，则fatal
  if [ -f "${dest_path}" ] && ! ${force}; then
    local file_hash=$(shasum -a 256 "${file_path}" | awk '{print $1}')
    if ! check_file_hash "${dest_path}" "${file_hash}"; then
      yxct_fatal "file already exist on dest path:${dest_path}. Use --force to overwrite the exist file"
    fi
  fi


  # 之前已经验证过 force了，这里仍然判断force参数， 避免多脚本同时执行
  local force_params=''
  if ${force}; then
    force_params='-f'
  fi

  yxct_verbcmd "${CP} ${force_params} ${file_path} ${bin_path}/${command}"
}


# 根据安装脚本路径，卸载可执行文件
function uninstall_by_script_path()
{
  local script_path=
  local additional=
  local bin_path=
  local command=

  local -a ignore_reg_list=
  local all=false

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in
      --path )
        shift
        script_path=$1
      ;;

      --command )
        shift
        command=$1
      ;;

      --bin-path )
        shift
        bin_path=$1
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --all )
        all=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
    esac
    shift
  done

  if [ -z "${script_path}" ]; then
    yxct_fatal "Script path is empty."
  fi

  # local all_params=''
  # if "${all}"; then
  #   all_params='--all'
  # fi

  local params=''
  #--command
  if [ -n "${command}" ]; then
    params="${params} --command ${command}"
  fi

  if [ -n "${bin_path}" ]; then
    params="${params} --bin-path ${bin_path}"
  fi

  if ${all}; then
    params="${params} --all"
  fi
  

  local result=1
  if [ -f "${script_path}" ]; then
  # 如果脚本路径是一个文件

    local script_file_name=$(basename "${script_path}")
    if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
    # 如果文件是一个安装脚本, 直接调用脚本
      run_setup_script uninstall --path "${script_path}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    else
      # 如果文件不是安装脚本，尝试使用 command 和 bin_path卸载。 并用这个文件做hash验证并卸载，并删除
      remove_by_hash_file --path "${script_path}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    fi
  elif [ -d "${script_path}" ]; then
  # 如果脚本路径是一个目录
    local uninstall_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
    if [[ -n "${uninstall_script_filename}" ]]; then
    # 如果目录中找到安装脚本, 直接掉用那个安装脚本
      run_setup_script uninstall --path "${script_path%\/}/${uninstall_script_filename}" ${params} ${additional}
      result=$?
      setup_cellar uninstall "${command}"
    else
    # 没找到那个安装脚本，查看是否是单脚本APP
      local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
      if [ -n "${singl_app_name}" ]; then
        # 如果文件夹下只找到一个文件，尝试使用 command 和 bin_path卸载。并使用这个文件做 hash 验证.
        remove_by_hash_file --path "${script_path%\/}/${singl_app_name}" ${params} ${additional}
        result=$?
        setup_cellar uninstall "${command}"
      else
        # 如果不是单脚本APP, 不知道如何安装
        yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to delete the command."
      fi
    fi
  else
  # 既不是文件，也不是目录，无效script_path
    yxct_fatal "Invalid script path:${script_path}"
  fi

  return "${result}"
}


# 根据可执行文件路径，卸载这个可执行文件
function uninstall_by_bin_path()
{
  local bin_path=
  local command=
  local additional=
  
  # 这个函数被调用，说明script_path 必定为空，之前判断过了

  while [ $# -gt 0 ]; do
    case $1 in
      --path )
        shift
        bin_path=$1
      ;;

      --command )
        shift
        command=$1
      ;; 

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done



  if [ -f "${bin_path}" ]; then
  # 如果bin_path 是个文件, 直接删除， command 提供验证
    if [ -n "${command}" ]; then
      local filename=$(basename "${bin_path}")
      if [[ "${filename}" != "${command}" ]]; then
        yxct_fatal "Filename name '${filename}' and command '${command}' not matched."
      fi

      local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
      if [ -n "${cellar_hash}" ]; then
        if ! check_file_hash "${bin_path}" "${cellar_hash}"; then
          yxct_fatal "failed to check hash value for execute file:${bin_path}"
        fi
      fi

        # # 要删除的文件必须和传入的文件相同
        # if ! check_file_hash "${finded_exec_path}" "${file_hash}"; then
        #   yxct_fatal "Script and execute file not matched:(${execute_file_path})"
        # fi
      # fi

    fi

    # 强制删除命令
    yxct_verbcmd "${RM} -f ${bin_path}"
    if [[ $? != 0 ]]; then
      yxct_fatal "Fail to uninstall '${command}' on path:${bin_path}"
    fi
    setup_cellar uninstall "${command}"
  elif [ -d "${bin_path}" ]; then
  # 如果bin_path 是个目录, 则command 不能为空, 根据command删除

    if [ -z "${command}" ]; then
      yxct_fatal "Can not find any script in path ${bin_path}"
    fi

    if ! [ -f "${execute_file_path}" ]; then
      echo_file "Script does not exist:${execute_file_path}"
    fi

    local execute_file_path="${bin_path}/${command}"
    local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
    if [ -n "${cellar_hash}" ]; then
      if ! check_file_hash "${execute_file_path}" "${cellar_hash}"; then
        yxct_fatal "failed to check hash value for execute file:${execute_file_path}"
      fi
    fi

    # 强制删除命令
    yxct_verbcmd "${RM} -f ${execute_file_path}"
    if [[ $? != 0 ]]; then
      yxct_fatal "Fail to uninstall '${command}' in path:${bin_path}"
    fi
    setup_cellar uninstall "${command}"
  else
    # 既不是文件，也不是目录，无效bin_path
    yxct_fatal "Invalid path:${bin_path}"
  fi

  return 0
}



###########################################################
# Usage
###########################################################

function yxct_usage()
{
cat <<EOF
  usage: ${CMD} <sub-command> <optional>
  Manage command tool

  usage: ${CMD} <sub-command> <--help|-h>
  For detail information for sub-command.

  usage: ${CMD} --help
  For this help information

  The following sub-command are allowed:
  install:      Install a command tool.
  uninstall:    Uninstall a command tool.
  update:       Update to newest version of ${CMD}
  pack:         Create or extra a ${CMD} package.

  Other options
  Use '${CMD} uninstall --help' show this help information
EOF
}

function yxct_usage_install()
{

  function __usage_install_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be install to'/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install
        the command to '/usr/local/bin' as default.
  
  Un-support destination options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be install to '/bin'
  --sbin                    The command will be install to '/sbin'
  --usr-bin                 The command will be install to '/usr/bin'
  --usr-local-bin           The command will be install to '/usr/local/bin'
  --usr-local-sbin          The command will be install to '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install the
        command to '/usr/local/bin' as default.
EOF
    fi
  }


cat <<EOF
  usage: ${CMD} install <command> <optional>
  Install a command

  usage: ${CMD} install --help
  Show this help information

  The following options are availiable:
  --path <path>             1. Point to an install script or a folder that contains an install script.
                            2. Point to a command file, ${CMD} will try to install the command to system.

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no install
                            script there. ${CMD} will not be able to determine which script to install.
                            use '--ignore' and indicate regulars expression to ignore useless files.
  
  --force                   If an existing file on bin-path, remove it.


  The followint options indicate destination path:
$(__usage_install_destination_info)
  

  The followint options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} install --help' show all help information
EOF
}

function yxct_usage_uninstall()
{

  function __usage_install_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be uninstall from '/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as target path.

  Note: If indicate a target path but the command not installed on that path, ${CMD} will do
        nothing and raise an error.
  
  Un-support target options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be uninstall from '/bin'
  --sbin                    The command will be uninstall from '/sbin'
  --usr-bin                 The command will be uninstall from '/usr/bin'
  --usr-local-bin           The command will be uninstall from '/usr/local/bin'
  --usr-local-sbin          The command will be uninstall from '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as target.

  Note: If indicate a target path but the command not installed on that path, ${CMD} will do
        nothing and raise an error.
EOF
    fi
  }

cat <<EOF
  usage: ${CMD} uninstall <command> <optional>
  Uninstall a command

  usage: ${CMD} uninstall --help
  Show this help information

  The following options are availiable:
  --path <path>             1. point to an uninstall script or a folder that contains an uninstall script.
                            2. point to a command file, ${CMD} will try to uninstall a same command on system.

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no uninstall
                            script there.  ${CMD} will not be able to determine which script to uninstall.
                            Use '--ignore' and indicate regulars expression to ignore useless files.
  
  --all                     If command installed on mutiple path and not indicate a target,
                            ${CMD} will try to delete all of them.


  The followint options indicate target path:
$(__usage_install_destination_info)


  The followint options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information
EOF
}


function yxct_usage_reinstall()
{

  function __usage_reinstall_destination_info()
  {
    if [[ "$(yxct_os_type)" == 'osx' ]]; then
cat << EOF
  --usr-local-bin           The command will be install to'/usr/local/bin' (It's the default optional)
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install
        the command to '/usr/local/bin' as default.
  
  Un-support destination options on OSX:
  --bin                     On OSX, this option will point to '/usr/loca/bin'
  --sbin                    On OSX, this option will point to '/usr/loca/bin'
  --usr-bin                 On OSX, this option will point to '/usr/loca/bin'
  --usr-local-sbin          On OSX, this option will point to '/usr/loca/bin'
EOF
    else
cat << EOF
  --bin                     The command will be install to '/bin'
  --sbin                    The command will be install to '/sbin'
  --usr-bin                 The command will be install to '/usr/bin'
  --usr-local-bin           The command will be install to '/usr/local/bin'
  --usr-local-sbin          The command will be install to '/usr/local/sbin'
  --custom-dest <path>      Indicate a custom path as destination.

  Note: If none of the above destination paths are specified, ${CMD} will install the
        command to '/usr/local/bin' as default.
EOF
    fi
  }


cat <<EOF
  usage: ${CMD} reinstall <command> <optional>
  Reinstall a command

  usage: ${CMD} reinstall --help
  Show this help information

  The following options are availiable:
  --path <path>             1. Point to an install script or a folder that contains an install script.
                            2. Point to a command file, ${CMD} will try to install the command to system.

  --ignore <reg1> <reg2>..  If '--path' point to a folder contains mutiple script but there is no install
                            script there. ${CMD} will not be able to determine which script to install.
                            use '--ignore' and indicate regulars expression to ignore useless files.
  
  --force                   If an existing file on bin-path, remove it.


  The followint options indicate destination path:
$(__usage_reinstall_destination_info)
  

  The followint options use for debug
  --test                    ${CMD} will not execute any comannd but output them into stdout instead.

  --no-depend               ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level              Command output level. 
                            The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                            or a number greater than 0.

  Other options
  Use '${CMD} install --help' show all help information
EOF
}


function yxct_usage_update()
{
cat <<EOF
  usage: ${CMD} update [--info-level xxx]
  Fetch the newest version of ${CMD} and all formulae from GitHub using git and perform any necessary migrations.

  The followint option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_pack()
{
cat <<EOF
  usage: ${CMD} pack <--repo-path path> <--pack-path path> [--pass xxx | --pass] [--force|--info-level]
  Create a ${CMD} installation pack from script.

  usage: ${CMD} unpack <--repo-path path> <--pack-path path> [--pass xxx | --pass] [--force|--info-level]
  Extra script from ${CMD} installation pack

  The followint option are availiable:
  --pass | --pass <xxx>   It's meand the installation package requires a password, and if no password
                          parameter is provided, ${CMD} will ask for a password during
                          the packing/unpacking process
  --force                 If an existing file or directory on target path, remove it.

  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function yxct_usage_list()
{
cat <<EOF
  usage: ${CMD} list [--info-level | --no-depend]
  Fetch the newest version of ${CMD} and all formulae from GitHub using git and perform any necessary migrations.

  The followint option are availiable:
  --no-depend             ${CMD} try not to depend on any other modules. It's a safe moodules.

  --info-level            Command output level. 
                          The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                          or a number greater than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


###########################################################
# Command
###########################################################


function cmd_install()
{
  local script_path=
  local bin_path=
  local -a ignore_reg_list=
  local additional=

  local force=false
  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        script_path=$1
      ;;

      --force )
        force=true
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --bin )
        bin_path="${BIN_PATH}"
      ;;

      --sbin )
        bin_path="${SBIN_PATH}"
      ;;

      --usr-bin )
        bin_path="${USR_BIN_PATH}"
      ;;

      --usr-sbin )
        bin_path="${USR_SBIN_PATH}"
      ;;

      --usr-local-bin )
        bin_path="${USR_LOCAL_BIN_PATH}"
      ;;

      --usr-local-sbin )
        bin_path="${USR_LOCAL_SBIN_PATH}"
      ;;

      --custom-dest )
        shift
        bin_path=$1
      ;;

      --test )
        test=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_install
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi


    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi 

    if [ -z "${script_path}" ]; then
      yxct_fatal "Script path is empty. Use --help to show more information."
    fi


    if [ -z "${bin_path}" ]; then
      bin_path="${DEFAULT_BIN_PATH}"
    fi



    local params=''
    # --command
    if [ -n "${command}" ]; then
      params="${params} --command ${command}"
    fi
    
    # --bin-path
    if [ -n "${bin_path}" ]; then
      params="${params} --bin-path ${bin_path}"
    fi


    local cmd_cellar_path=$(yxct_get_cellar_item "${command}" --cellar-path)
    if ! [ -d "${cmd_cellar_path}" ]; then

      if [ -f "${script_path}" ]; then
      # 如果脚本路径是一个文件

        local script_file_name=$(basename ${script_path})
        if echo "${script_file_name}" | grep -Eq "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$"; then
        # 如果文件是一个安装脚本, 直接调用脚本
          if run_setup_script install --path "${script_path}" ${params} ${additional}; then
            setup_cellar install "${command}" --install-script "${script_path}"
          else
            yxct_fatal "failed on install ${command}"
          fi
        else
        # 如果文件是不是一个安装脚本

          local force_params=''
          if ${force}; then
            force_params='--force'
          fi

          if [[ "${script_file_name}" == "${command}" ]] ||  [[ "${script_file_name%.*}" == "${command}" ]]; then
          # 如果'--path'指向的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
            if install_file --file "${script_path}" "${force_params}" ${params}; then
              setup_cellar install "${command}" --install-file "${script_path}" 
            else
              yxct_fatal "failed on install ${command}"
            fi
          else
          # '--path'指向文件名与'command'不同的情况下，验证是否指定了 ‘--strict’ 参数. 没指定则强制安装文件, 并改名为command.
            if install_file --file "${script_path}" "${force_params}" ${params}; then
              setup_cellar install "${command}" --install-file "${script_path}" 
            else
              yxct_fatal "failed on install ${command}"
            fi
          fi

        fi
      elif [ -d "${script_path}" ]; then
        # 如果脚本路径是一个目录
        local install_script_filename=$(search_file_by_reg_list "${script_path}" "^\s*\.${CMD}.setup(\.sh|\.py|\.rb)?\s*$")
        if [ -n "${install_script_filename}" ]; then
          # 如果目录中找到安装脚本, 直接掉用那个安装脚本
          local script_path="${script_path%\/}/${install_script_filename}"
          if run_setup_script install --path "${script_path}" ${params} ${additional}; then
            setup_cellar install "${command}" --install-script "${script_path}"
          else
            yxct_fatal "failed on install ${command}"
          fi
        else

          local singl_app_name=$(file_name_if_single "${script_path}" --ignore ${ignore_reg_list[@]})
          if [ -n "${singl_app_name}" ]; then
          # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，只剩下一个文件

            local force_params=''
            if ${force}; then
              force_params='--force'
            fi
            
            local app_path="${script_path%\/}/${singl_app_name}"
            if [[ "${singl_app_name}" == "${command}" ]] ||  [[ "${singl_app_name%.*}" == "${command}" ]]; then
            # 如果这唯一的文件与要安装的'command'名字相同(或去掉扩展名后相同), 则安装文件
              if install_file --file "${app_path}" "${force_params}" ${params}; then
                setup_cellar install "${command}" --install-file "${script_path}"
              else
                yxct_fatal "failed on install ${command}"
              fi
            else
            # 这唯一的文件与'command'名字不同的情况下，没指定则强制安装文件, 并改名为command.
              if install_file --file "${app_path}" "${force_params}" ${params}; then
                setup_cellar install "${command}" --install-file "${script_path}"
              else
                yxct_fatal "failed on install ${command}"
              fi
            fi
          else
            # 如果目录中文件，去掉白名单的文件和--ignore正则指定忽略的文件后，还有多个文件，则不知道如何安装, 直接报错
            yxct_fatal "There are mutiple files in script path, but no install script found. ${CMD} don't know how to install the command."
          fi

        fi
      else
      # 既不是文件，也不是目录，无效script_path
        yxct_fatal "Invalid script path:${script_path}"
      fi

    else # end of (if ! [ -d "${cmd_cellar_path}" ]; then)

      yxct_msg "${command} is already installed."
      exit 1

    fi # end of (if ! [ -d "${cmd_cellar_path}" ]; then)

  fi

  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    yxct_msg "${command} install success."
  fi
}


function cmd_uninstall()
{
  local bin_path=
  local -a ignore_reg_list=
  local additional=

  local all=false
  local test=false

  local info_level=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi

  local is_in_ignore=false
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --path )
        shift
        script_path=$1
      ;;

      --all )
        all=true
      ;;

      --ignore )
        is_in_ignore=true
        force=true
      ;;

      --bin )
        bin_path="${BIN_PATH}"
      ;;

      --sbin )
        bin_path="${SBIN_PATH}"
      ;;

      --usr-bin )
        bin_path="${USR_BIN_PATH}"
      ;;

      --usr-sbin )
        bin_path="${USR_SBIN_PATH}"
      ;;

      --usr-local-bin )
        bin_path="${USR_LOCAL_BIN_PATH}"
      ;;

      --usr-local-sbin )
        bin_path="${USR_LOCAL_SBIN_PATH}"
      ;;

      --custom-dest )
        shift
        bin_path=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --test )
        test=true;
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        if ${is_in_ignore}; then
          ignore_reg_list=("${ignore_reg_list[@]}" "${1}")
        else
          additional="${additional} $1"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_uninstall
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if ${test}; then
      TEST_ONLY=true
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    # 为了保证输出正常，这个只能放在 'info_level' 之后
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi


    local params=''
    if [ -n "${command}" ]; then
      params="${params} --command ${command}"
    fi


    # try fix setup script path from cellar if it not exist
    local setup_script_path="${script_path}"
    if [ -z "${setup_script_path}" ]; then
      setup_script_path=$(yxct_get_cellar_item "${command}" --setup-script)
    fi


    local result=
    if [ -n "${setup_script_path}" ]; then
      # 如果提供了脚本路径, 或从cellar找到了当时安装时的setup脚本

      if [ -n "${bin_path}" ]; then
        params="${params} --bin-path ${bin_path}"
      fi
      if ${all}; then
        params="${params} --all"
      fi


      uninstall_by_script_path --path "${setup_script_path}" ${params} --ignore ${ignore_reg_list[@]} ${additional}
      result=$?

    elif [ -n "${bin_path}" ]; then
      # 如果找不到脚本路径， 但bin_path不为空

      uninstall_by_bin_path --path "${bin_path}" ${params}
      result=$?
    elif [ -n "${command}" ]; then
      # 如果没提供脚本路径和bin_path, 但提供了command

      if ${all}; then
        params="${params} --all"
      fi

      local cellar_hash=$(yxct_get_cellar_item "${command}" --command-hash)
      if [ -n "${cellar_hash}" ]; then
        params="${params} --hash ${cellar_hash}"
      fi

      remove_command ${params}
      result=$?
    else
      yxct_fatal "Invalid parameters, use --help to show more information."
    fi
  fi


  if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
    if [[ "${result}" == 0 ]]; then
      yxct_msg "${command} uninstall success."
    else
      yxct_fatal "failed uninstall ${command}."
    fi
  fi

}

function cmd_update()
{
  local repo="${DIR}"
  local info_level=
  local no_depend=false
  local show_help=false

  while [ $# -gt 0 ]; do
    case $1 in
      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        yxct_fatal "Invalid params:${$1}"
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_update
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    # Force root
    if [ "$(id -u)" -ne 0 ]; then
      yxct_fatal "'${CMD} update' command should run with root"
    fi


    # yxct 预计的环境，很大可能是没有git的...
    if ! which git > /dev/null; then
      yxct_fatal "can not find git command."
    fi

    yxct_msg "check update info..."
    yxct_verbcmd "git -C ${repo} fetch"
    local git_head=$(git -C "${repo}" log HEAD | head -n 1 | awk '{print $2}')
    local git_fetch_head=$(git -C "${repo}" log FETCH_HEAD | head -n 1 | awk '{print $2}')
    yxct_verbose "head:${git_head}"
    yxct_verbose "new:${git_fetch_head}"

    if [[ "${git_head}" != "${git_fetch_head}" ]]; then
      yxct_msg "begin update..."
      
      # check the repo
      local git_status=
      if ! git_status=$(git -C "${repo}" status --porcelain=v1); then
        yxct_fatal "failed to get git status"
      fi
      
      if [ -n "${git_status}" ]; then
        yxct_msg "the repo is dirty, try recover..."
        
        # clean the repo
        yxct_verbcmd "git -C ${repo} reset --hard HEAD --"
        yxct_verbcmd "git -C ${repo} clean -fd"
        
        # check clean result
        if ! git_status=$(git -C "${repo}" status --porcelain=v1); then
          yxct_fatal "failed to get git status after clean yxct repo"
        fi
        if [ -n "${git_status}" ]; then
          yxct_fatal "failed to clean ${CMD} repo"
        fi
      fi
      
      #pull the repo
      if ! yxct_verbcmd "git -C ${repo} pull"; then
        yxct_fatal "failed to pull repo"
      fi
      
      # re-check upgrade result.
      git_head=$(git -C "${repo}" log HEAD | head -n 1 | awk '{print $2}')
      if [[ "${git_head}" == "${git_fetch_head}" ]]; then
        yxct_msg 'upgrade success.'
      else
        yxct_fatal 'upgrade failed.'
      fi
      
    else
      yxct_msg "${CMD} is already the latest version"
    fi

  fi

}

function cmd_reinstall()
{
  local test=false
  local info_level=
  local additional=
  local no_depend=false
  local show_help=false

  local command=
  if ! [[ "$1" =~ ^-.*$ ]]; then
    command=$1
    shift
  fi 


  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --test )
        test=true
      ;;

      --no-depend )
        no_depend=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
    esac
    shift
  done


  if ${show_help}; then
    yxct_usage_reinstall
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -z "${command}" ]; then
      yxct_fatal "Command is empty. Use --help to show more information."
    fi
    # 如果操作的是'yxlib', 强制关闭 'YXCT_USEYXLIB'
    if yxct_strcontains "${command}" "yxlib" --ignorecase; then
      export YXCT_USEYXLIB=false
    fi

    local params=
    if ${test}; then
      params="${params} --test"
    fi

    if ${no_depend}; then
      params="${params} --no-depend"
    fi

    if [ -n "${info_level}" ]; then
      params="${params} --info-level ${info_level}"
    fi


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    if ! cmd_uninstall "${command}" ${params} ; then
      yxct_fatal "failed on remove old ${command}"
    fi
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
    cmd_install "${command}" ${params} ${additional};
    local result=$?
    YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))


    if [[ "${YXCT_NESTED_FLAG}" == 1 ]]; then
      if [[ "${result}" == 0 ]]; then
        yxct_msg "${command} reinstall success."
      fi
    fi

  fi

}


function cmd_pack()
{
  local repo_path=
  local pack_path=
  local pass=
  # local command=
  local encrypt=false
  local force=false

  local info_level=
  local no_depend=false
  local show_help=false
  local option=

  if ! [[ $1 =~ ^-.*$ ]]; then
    if yxct_strcontains "${1}" "pack" --ignorecase; then
      option='PACK'
    elif yxct_strcontains "${1}" "unpack" --ignorecase; then
      option='UNPACK'
    else
      option=$1
    fi
    shift
  fi

  # if ! [[ $1 =~ ^-.*$ ]]; then
  #   command=$1
  #   shift
  # fi

  local cursor=
  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --repo-path )
        cursor=$1
      ;;

      --pack-path )
        cursor=$1
      ;;

      --pass )
        encrypt=true
        cursor=$1
      ;;

      --force )
        cursor=
        force=true
      ;;

      --info-level )
        shift
        cursor=
        info_level=$1
      ;;

      --no-depend )
        cursor=
        no_depend=true
      ;;

      --help | h )
        cursor=
        show_help=true
      ;;

      *)
        if [[ $1 =~ ^-.*$ ]]; then
          cursor=
        fi
        if [ -n "${cursor}" ]; then
          if [[ "${cursor}" == '--repo-path' ]]; then
            repo_path=$(echo "${repo_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--pack-path' ]]; then
            pack_path=$(echo "${pack_path} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${cursor}" == '--pass' ]]; then
            pass=$(echo "${pass} $1" | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          else
            yx_fatal "Invalid name of ${cursor} $1"
          fi
        else
          yx_fatal "Invalid optional ${1}"
        fi
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_pack
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    if [[ "${option}" == 'PACK' ]]; then
      

      if [ -z "${repo_path}" ]; then
        yxct_fatal "repo path is empty. Use '${CMD} pack --help' to show help information"
      fi

      if [ -z "${pack_path}" ]; then
        yxct_fatal "package path is empty"
      fi

      # Create a temp directory
      local tmp_path=$(mktemp -d)
      if [ ! -d "${tmp_path}" ]; then
        yxct_fatal "Failed to create a temp directory"
      fi

      local command=$(basename "${repo_path}")

      # Compress the package
      local tar_file="${tmp_path%\/}/tar"
      pushd $(dirname "${repo_path}") > /dev/null || yxct_fatal "failed to pushd ${repo_path}"
      yxct_verbcmd "${TAR} --create --file ${tar_file} ${command}"
      popd > /dev/null || yxct_fatal "failed to popd from ${repo_path}"


      # encrypt if need
      local target_file=
      local pack_file=
      if ${encrypt}; then

        local encrypt_file="${tmp_path%\/}/encrypted"
        if [ -z "${pass}" ]; then
          if [ -z "${pkg_pass}" ]; then
            local pass1=
            local pass2=
            echo -n "Enter encryption password:"
            read -s pass1
            echo ""

            echo -n "Verifying encryption password:"
            read -s pass2
            echo ""

            if [[ "${pass1}" == "${pass2}" ]]; then
              pass="${pass1}"
            else
              echo_fatal "Password not matched"
            fi
          fi
        fi

        if ! yxct_verbcmd "${OPENSSL} enc -e -aes256 -iter 100 -pbkdf2 -in ${tar_file} -out ${encrypt_file} --pass pass:${pass}"; then
          yxct_fatal "Failed to encrypt package"
        fi

        target_file="${encrypt_file}"
        # pack_file="${pack_path}/${command}.yxct"
      
      else
        target_file="${tar_file}"
        # pack_file="${pack_path}/${command}.yxct"
      fi

      # Make pack file's dir if not exist
      if ! [ -d "${pack_path}" ]; then
        yxct_err "${pack_path} not exist, try create one"
        yxct_verbcmd "${MKDIR} -p ${pack_path}" > /dev/null
        if ! [ -d "${pack_path}" ]; then
          yxct_fatal "failed to mkdir ${pack_path}"
        fi
      fi

      # copy file
      local force_params=''
      local pack_file="${pack_path}/${command}.yxct"
      if [ -f "${pack_file}" ]; then
        if "${force}"; then
          force_params="-f"
        else
          yxct_fatal "file ${pack_file} already exist, use '--force' to replace it or '${CMD} pack --help' to show help information"
        fi
      fi

      if ! yxct_verbcmd "${CP} ${force_params} ${target_file} ${pack_file}"; then
        yxct_fatal "failed to copy file to ${pack_file}"
      else
        yxct_msg "pack success"
      fi

     
    elif [[ "${option}" == 'UNPACK' ]]; then
      if [ -z "${repo_path}" ]; then
        yxct_fatal "repo path is empty. Use '${CMD} pack --help' to show help information"
      fi

      if [ -z "${pack_path}" ]; then
        yxct_fatal "package path is empty"
      elif ! [ -f "${pack_path}" ]; then
        yxct_fatal "package path ${pack_path} not exist"
      fi


      # Create a temp directory
      local tmp_path=$(mktemp -d)
      if [ ! -d "${tmp_path}" ]; then
        yxct_fatal "Failed to create a temp directory"
      fi




      # decrypt if need
      # target_path & repo_path
      local target_path=
      local filename=$(basename "${pack_path}")
      if ! "${TAR}" -tf "${pack_path}" &> /dev/null; then
        local decrpyt_file="${tmp_path%\/}/decrypt"

        local pass_param=''
        if [ -n "${pass}" ]; then
          pass_param="--pass pass:${pass}"
        fi
        if ! "${OPENSSL}" enc -d -aes256 -iter 100 -pbkdf2 -in "${pack_path}" --out "${decrpyt_file}" ${pass_param}; then
          yxct_fatal "failed to dencrypt file:${pack_path}"
        fi

        target_path="${decrpyt_file}"
      else
        target_path="${pack_path}"
      fi


      # extract package
      local extra_path="${tmp_path%\/}/extra"
      if ! "${MKDIR}" -p "${extra_path}"; then
        yxct_fatal "failed to make dir:${target_path}"
      fi
      if ! yxct_verbcmd "/usr/bin/tar --extract --file=${target_path} --directory=${extra_path}"; then
        yxct_fatal "failed to extract package"
      fi
      target_path="${extra_path}"


      # search extract result
      # must only one file or directory in package.
      local repo_name=
      local finded=false
      for file in "${target_path%\/}"/*; do
        if ${finded}; then
          yxct_fatal "mutiple files or directory in package"
        fi

        finded=true
        repo_name=$(basename "${file}")
      done

      if [ -z "${repo_name}" ]; then
        yxct_fatal "failed to find file or directory in package"
      fi

      target_path="${target_path%\/}"/${repo_name}



      # Make repo file's dir if not exist
      if ! [ -d "${repo_path}" ]; then
        yxct_err "${repo_path} not exist, try create one"
        yxct_verbcmd "${MKDIR} -p ${repo_path}" > /dev/null
        if ! [ -d "${repo_path}" ]; then
          echo_fatal "failed to mkdir ${repo_path}"
        fi
      fi

      # copy file
      local params=''
      if [ -f "${repo_path}" ]; then
        if "${force}"; then
          params="-f"
        else
          yxct_fatal "file ${repo_path} already exist, use '--force' to replace it or '${CMD} unpack --help' to show help information"
        fi
      fi

      if [ -d "${target_path}" ]; then
        params="${params} -R"
      fi

      if ! yxct_verbcmd "${CP} ${params} ${target_path%\/}/${repo_name} ${repo_path}"; then
        yxct_fatal "failed to copy file to ${pack_file}"
      else
        yxct_msg "unpack success"
      fi


    fi # end of(if [[ "${option}" == 'PACK' ]]; then)


  fi # end of (if ${show_help}; then)
}


function cmd_list()
{
  local info_level=
  local no_depend=false
  local show_help=false

  while [ $# -gt 0 ]; do

    if [[ $1 =~ ^--.*$ ]]; then
      is_in_ignore=false
    fi

    case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --no-depend )
        no_depend=true
      ;;

      --help | h )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
    esac
    shift
  done

  if ${show_help}; then
    yxct_usage_list
    exit 0
  else

    if ${no_depend}; then
      export YXCT_USEYXLIB=false
    fi

    if [ -n "${info_level}" ]; then
      yxct_set_info_level "${info_level}"
    fi


    local cmd_cellar_path=$(yxct_get_cellar_item "${CMD}" --cellar-path)
    if [ -z "${cmd_cellar_path}" ]; then
      yxct_fatal "failed to get command cellar path"
    fi

    local cellar_path=$(dirname "${cmd_cellar_path}")
    if [ -z "${cellar_path}" ]; then
      yxct_fatal "failed to get cellar path"
    fi

    for item in "${cellar_path%\/}"/*; do
      basename "${item}"
    done

  fi

}


####################################################################################################
# Entry
####################################################################################################


# 不要限制'PATH', 会引起`which`命令无法查找
# PATH=/sbin:/bin:/usr/bin

# 设置默认日志级别。
if [ -n "${YXLOGGER_DEFAULT_LEVEL}" ]; then
  # 尝试继承当前环境中YXLib的日志级别。
  yxct_set_info_level "${YXLOGGER_DEFAULT_LEVEL}"
else
  # 使用 yxct 级别 设置日志级别
  # 注意: 这里扔需要设置一次
  # 因为 yxct_set_inf_level 可能需要将默认参数透传给 YXLogger
  yxct_set_info_level "${YXCT_DEFAULT_LEVEL}"
fi

# 如果syslog的tag没被设置(没有上层脚本), 则将其设置为${CMD}
if [ -n "${YXLOGGER_SYSLOG_TAG}" ]; then
  YXLOGGER_SYSLOG_TAG="${CMD}"
fi

if [[ $(yxct_os_type) == 'osx' ]]; then
  # on osx, '/usr/local/sbin' is not a standard bin path
  BIN_PATH="${USR_LOCAL_BIN_PATH}"
  SBIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_BIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_SBIN_PATH="${USR_LOCAL_BIN_PATH}"
  USR_LOCAL_SBIN_PATH="${USR_LOCAL_BIN_PATH}"

  CP=/bin/cp
  RM=/bin/rm
  CHMOD=/bin/chmod
  BASH=/bin/bash
  ENV=/usr/bin/env
  MKDIR=/bin/mkdir
  LN=/bin/ln
  TAR=/usr/bin/tar
  OPENSSL=/usr/local/bin/openssl
else
  CP=/usr/bin/cp
  RM=/usr/bin/rm
  CHMOD=/usr/bin/chmod
  BASH=/bin/bash
  ENV=/usr/bin/env
  MKDIR=/usr/bin/mkdir
  LN=/usr/bin/ln
  TAR=/usr/bin/tar
  OPENSSL=/usr/bin/openssl
fi



sub_cmd=$1
shift
if [[ -z ${sub_cmd} ]]; then
  yxct_fatal "Param error. use '${CMD} --help' to show document"
fi




if [ -z "${YXCT_NESTED_FLAG}" ]; then
  export YXCT_NESTED_FLAG=1
else
  YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG+1))
fi


if [[ "${sub_cmd}" == 'install' ]]; then
  cmd_install $@;
elif [[ "${sub_cmd}" == 'uninstall' ]]; then
  cmd_uninstall $@
elif [[ "${sub_cmd}" == 'reinstall' ]]; then
  cmd_reinstall $@
elif [[ "${sub_cmd}" == 'update' ]]; then
  cmd_update $@
elif [[ "${sub_cmd}" == 'list' ]]; then
  cmd_list $@
elif [[ "${sub_cmd}" == 'pack' ]]; then
  cmd_pack pack $@
elif [[ "${sub_cmd}" == 'unpack' ]]; then
  cmd_pack unpack $@
elif [[ "${sub_cmd}" == '-' ]]; then
  : # nested call. do nothing ...
elif [[ "${sub_cmd}" == '--help' ]] || [[ "${sub_cmd}" == '-h' ]]; then
  yxct_usage
else
  yxct_fatal "Unknown sub command:'${sub_cmd}'. Use ${CMD} --help tho show help information."
fi


YXCT_NESTED_FLAG=$((YXCT_NESTED_FLAG-1))